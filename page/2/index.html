<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Quantity Accumulation and Quality Leap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Quantity Accumulation and Quality Leap">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Quantity Accumulation and Quality Leap">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Quantity Accumulation and Quality Leap">
  
    <link rel="alternate" href="/atom.xml" title="Quantity Accumulation and Quality Leap" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Quantity Accumulation and Quality Leap</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-集合【LinkedList、HashSet、Collection集合体系】" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/10/集合【LinkedList、HashSet、Collection集合体系】/" class="article-date">
  <time datetime="2019-01-10T15:13:48.000Z" itemprop="datePublished">2019-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/10/集合【LinkedList、HashSet、Collection集合体系】/">集合【LinkedList、HashSet、Collection集合体系】</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <section class="_editor"><section style="margin:10px 0px;border-style:solid;border-width:6px;border-color:#c42a1d;border-radius: 10px;color: #e15185;box-sizing: border-box;"><section style="border-width: 1px;border-style: dashed;border-color: #c42a1d;background: url(https://mmbiz.qpic.cn/mmbiz_png/Ljib4So7yuWjbu29TfWUud9tJjCpM1Y2a23MJ0w22CLdEMjR05r4VPhq0ic5yeVe0icrGxGAGFpacliahA9oYQlRMQ/0?wx_fmt=png) center bottom / 20% no-repeat;box-sizing: border-box;"><section style="background-color: rgba(255, 255, 255, 0.77);padding: 1em;font-size: 14px;letter-spacing: 1.5px;line-height: 1.75em;text-align: justify;color: #666666;box-sizing: border-box;"><p>新的起点是成功的开端，目标是行动的航标。一个人生活中没有任何目标，就如大海中漂泊的孤舟，不是稳步前进，而是随波逐流。</p></section></section></section></section><p><span style="font-family:宋体">第</span>8<span style="font-family:宋体">天</span> <span style="font-family:宋体">集合</span></p><p><span style="font-size:21px">今日学习内容</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">List</span><span style="font-size:14px;font-family:宋体;font-weight:normal">集合</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">Set</span><span style="font-size:14px;font-family:宋体;font-weight:normal">集合</span></p><p><span style="font-size:21px">今日学习目标</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">能够说出</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">List</span><span style="font-size:14px;font-family:宋体;font-weight:normal">集合特点</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">:</span><span style="font-size: 14px;font-family:宋体;font-weight:normal">有序</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">,</span><span style="font-size: 14px;font-family:宋体;font-weight:normal">索引和重复</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">使用</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">List</span><span style="font-size:14px;font-family:宋体;font-weight:normal">存储的数据结构</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">:ArrayList</span><span style="font-size:14px;font-family:宋体;font-weight:normal">是数组结构</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal"> LinkedList</span><span style="font-size:14px;font-family:宋体;font-weight:normal">是链表结构</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">能够说出</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">List</span><span style="font-size:14px;font-family:宋体;font-weight:normal">常见的三个的特点</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">能够说出</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">Set</span><span style="font-size:14px;font-family:宋体;font-weight:normal">集合的特点</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">:</span><span style="font-size: 14px;font-family:宋体;font-weight:normal">无索引</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">,</span><span style="font-size: 14px;font-family:宋体;font-weight:normal">不重复</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">说出哈希表的特点</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">使用</span><span style="font-size:14px;font-family:'Calibri','sans-serif';font-weight:normal">HashSet</span><span style="font-size:14px;font-family:宋体;font-weight:normal">集合存储自定义元素</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">说出判断集合元素唯一的原理</span></p><h1 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">第1章<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">数据结构</span></h1><h2 style="margin: 17px 14px 17px 52px; font-weight: bold; font-size: 16px; line-height: 1.6em;">1.1<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>List<span style="font-family:华文楷体">集合存储数据的结构</span></h2><p style="text-indent:28px">List<span style="font-family:宋体">接口下有很多个集合，它们存储元素所采用的结构方式是不同的，这样就导致了这些集合有它们各自的特点，供给我们在不同的环境下进行使用。数据存储的常用结构有：堆栈、队列、数组、链表。我们分别来了解一下：</span> </p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>堆栈，采用该结构的集合，对元素的存取有如下的特点：</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>栈的入口、出口的都是栈的顶端位置</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</p><p style="margin-left:28px;text-indent:0"><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132819796798.png" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132819796798.png" alt="1.PNG"></p><p style="margin-left:28px;text-indent:0"><br></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>队列，采用该结构的集合，对元素的存取有如下的特点：</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，安检。排成一列，每个人依次检查，只有前面的人全部检查完毕后，才能排到当前的人进行检查。</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</p><p style="margin-left:28px;text-indent:0"><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132837286216.png" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132837286216.png" alt="2.PNG"></p><p style="margin-left:28px;text-indent:0"><br></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>数组，采用该结构的集合，对元素的存取有如下的特点：</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>查找元素快：通过索引，可以快速访问指定位置的元素</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>增删元素慢：</p><p style="margin-left:112px"><span style="font-family:Wingdings">u<span style="font:9px 'Times New Roman'">&nbsp; </span></span><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图</p><p style="margin-left:112px"><span style="font-family:Wingdings">u<span style="font:9px 'Times New Roman'">&nbsp; </span></span><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</p><p style="margin-left:28px;text-indent:0"><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132851164924.png" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132851164924.png" alt="3.PNG"></p><p style="margin-left:28px;text-indent:0"><br></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>链表，采用该结构的集合，对元素的存取有如下的特点：</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>多个节点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>增删元素快：</p><p style="margin-left:112px"><span style="font-family:Wingdings">u<span style="font:9px 'Times New Roman'">&nbsp; </span></span>增加元素：操作如左图，只需要修改连接下个元素的地址即可。</p><p style="margin-left:112px"><span style="font-family:Wingdings">u<span style="font:9px 'Times New Roman'">&nbsp; </span></span>删除元素：操作如右图，只需要修改连接下个元素的地址即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132875881935.png" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132875881935.png" alt="4.PNG"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">1.2<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>LinkedList<span style="font-family:华文楷体">集合</span>(<span style="font-family: 华文楷体">有空可以先看一下</span>List<span style="font-family:华文楷体">这个接口和方法</span>,<span style="font-family:华文楷体">以及</span>List<span style="font-family: 华文楷体">实现类的各种数据结构特点</span>)</h2><p style="text-indent:28px">LinkedList<span style="font-family:宋体">集合数据存储的结构是链表结构。方便元素添加、删除的集合。实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而</span>LinkedList<span style="font-family:宋体">提供了大量首尾操作的方法。如下图</span></p><p style="text-indent:28px"><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132894531904.png" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132894531904.png" alt="5.PNG"></p><p style="text-indent:28px"><br></p><p style="text-indent:28px"><span style=";background:white;background: white">LinkedList</span><span style="font-family:宋体;background:white;background:white">是</span><span style="background:white;background:white">List</span><span style="font-family: 宋体;background:white;background:white">的子类，</span><span style="background:white;background:white">List</span><span style="font-family:宋体;background:white;background:white">中的方法</span><span style="background:white;background:white">LinkedList</span><span style="font-family:宋体;background:white;background:white">都是可以使用，这里就不做详细介绍，我们只需要了解</span><span style="background:white;background:white">LinkedList</span><span style="font-family:宋体;background:white;background:white">的特有方法即可。</span><span style="font-family:宋体">在开发时，</span>LinkedList<span style="font-family:宋体">集合也可以作为</span><span style="font-family: 宋体;color:black;background:white;background:white">堆栈，队列的结构使用。</span></p><p style="text-indent:28px"><span style="font-family:宋体;background:white;background:white">方法演示：</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LinkedList&lt;String&gt; link = <strong><span style="color:#7F0055">new</span></strong> LinkedList&lt;String&gt;();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<span style="font-family:宋体">添加元素</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link.addFirst(<span style="color:#2A00FF">“abc1”</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link.addFirst(<span style="color:#2A00FF">“abc2”</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link.addFirst(<span style="color:#2A00FF">“abc3”</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<span style="font-family:宋体">获取元素</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em><span style="color:#0000C0">out</span></em>.println(link.getFirst());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em><span style="color:#0000C0">out</span></em>.println(link.getLast());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<span style="font-family:宋体">删除元素</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em><span style="color:#0000C0">out</span></em>.println(link.removeFirst());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em><span style="color:#0000C0">out</span></em>.println(link.removeLast());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><span style="color:#7F0055">while</span></strong>(!link.isEmpty()){ //<span style="font-family:宋体">判断集合是否为空</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em><span style="color:#0000C0">out</span></em>.println(link.pop()); //<span style="font-family:宋体">弹出集合中的栈顶元素</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><h1 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">第2章<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span>Set接口(<span style="font-family:宋体">特点以及方法</span>?)</h1><p style="text-indent:28px"><span style="font-family:宋体">查阅</span>Set<span style="font-family:宋体">集合的</span>API<span style="font-family:宋体">介绍，通过元素的</span>equals<span style="font-family:宋体">方法，来判断是否为重复元素，它是个<span style="background:white;background:white">不包含重复元素的集合。</span></span><span style="background:white;background:white">Set</span><span style="font-family:宋体;background:white;background:white">集合取出元素的方式可以采用：迭代器、增强</span><span style="background:white;background:white">for</span><span style="font-family:宋体;background:white;background:white">。</span></p><p style="text-indent:28px"><span style="background:white;background:white">Set</span><span style="font-family: 宋体;background:white;background:white">集合有多个子类，这里我们介绍其中的</span><span style="background:white;background:white">HashSet</span><span style="font-family:宋体;background:white;background:white">、</span><span style="background:white;background:white">LinkedHashSet</span><span style="font-family:宋体;background:white;background:white">这两个集合。</span></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;"><span style=";background:white;background:white">2.1<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="background:white;background:white">HashSet</span><span style="font-family:华文楷体;background:white;background:white">集合介绍</span></h2><p style="text-indent:28px"><span style="font-family:宋体">查阅</span>HashSet<span style="font-family:宋体">集合的</span>API<span style="font-family:宋体">介绍：此类实现</span>Set<span style="font-family:宋体">接口，由哈希表支持（实际上是一个</span> <tt><span style="font-size:16px">HashMap</span></tt><tt><span style="font-size:16px">集合</span></tt><span style="font-family:宋体">）。</span>HashSet<span style="font-family:宋体">集合不能保证的迭代顺序与元素存储顺序相同。</span></p><p style="text-indent:28px"><span style="background:white;background:white">HashSet</span><span style="font-family:宋体;background:white;background:white">集合，采用哈希表结构存储数据，保证元素唯一性的方式依赖于：</span><span style="background:white;background:white">hashCode()</span><span style="font-family:宋体;background:white;background:white">与</span><span style="background:white;background:white">equals()</span><span style="font-family:宋体;background:white;background:white">方法。</span></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">2.2<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>HashSet<span style="font-family:华文楷体">集合存储数据的结构（哈希表）</span></h2><p style="text-indent:28px"><span style="font-family:宋体">什么是哈希</span> <span style="font-family:宋体">呢？</span></p><p style="text-indent:28px"><span style="font-family:宋体">哈希表底层使用的也是数组机制，数组中也存放对象，而这些对象往数组中存放时的位置比较特殊，当需要把这些对象给数组中存放时，那么会根据这些对象的特有数据结合相应的算法，计算出这个对象在数组中的位置，然后把这个对象存放在数组中。而这样的数组就称为哈希数组，即就是哈希表。</span></p><p style="text-indent:28px"><span style="font-family:宋体">当向哈希表中存放元素时，需要根据元素的特有数据结合相应的算法，这个算法其实就是</span>Object<span style="font-family:宋体">类中的</span>hashCode<span style="font-family:宋体">方法。由于任何对象都是</span>Object<span style="font-family:宋体">类的子类，所以任何对象有拥有这个方法。即就是在给哈希表中存放对象时，会调用对象的</span>hashCode<span style="font-family:宋体">方法，算出对象在表中的存放位置，这里需要注意，如果两个对象</span>hashCode<span style="font-family:宋体">方法算出结果一样，这样现象称为哈希冲突，这时会调用对象的</span>equals<span style="font-family:宋体">方法，比较这两个对象是不是同一个对象，如果</span>equals<span style="font-family:宋体">方法返回的是</span>true<span style="font-family:宋体">，那么就不会把第二个对象存放在哈希表中，如果返回的是</span>false<span style="font-family:宋体">，就会把这个值存放在哈希表中。</span></p><p style="text-indent:28px"><span style="font-family:宋体">注意</span>:String<span style="font-family:宋体">类重写了</span>hashcode<span style="font-family:宋体">方法</span>,<span style="font-family:宋体">按照自己的方式计算</span>,”abc”<span style="font-family:宋体">和</span>”acD”<span style="font-family:宋体">哈希值相同</span></p><p style="text-indent:28px"><span style="font-family:宋体">总结：保证</span>HashSet<span style="font-family:宋体">集合元素的唯一，其实就是根据对象的</span>hashCode<span style="font-family:宋体">和</span>equals<span style="font-family:宋体">方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写</span>hashCode<span style="font-family:宋体">和</span>equals<span style="font-family:宋体">方法建立属于当前对象的比较方式。</span></p><p><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132917495445.png" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132917495445.png" alt="6.PNG"></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">2.3<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>HashSet<span style="font-family:华文楷体">存储</span>JavaAPI<span style="font-family:华文楷体">中的类型元素</span></h2><p style="text-indent:28px"><span style="font-family:宋体">给</span>HashSet<span style="font-family:宋体">中存储</span>JavaAPI<span style="font-family:宋体">中提供的类型元素时，不需要重写元素的</span>hashCode<span style="font-family:宋体">和</span>equals<span style="font-family:宋体">方法，因为这两个方法，在</span>JavaAPI<span style="font-family:宋体">的每个类中已经重写完毕，如</span>String<span style="font-family:宋体">类、</span>Integer<span style="font-family:宋体">类等。</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>创建HashSet集合，存储String对象。</p><p><strong><span style="color:#7F0055">publicclass</span></strong> HashSetDemo {</p><p>&nbsp;&nbsp;&nbsp; <strong><span style="color:#7F0055">publicstaticvoid</span></strong> main(String[] args) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#3F7F5F">//</span><span style="font-family:宋体;color:#3F7F5F">创建</span><span style="color:#3F7F5F">HashSet</span><span style="font-family:宋体;color:#3F7F5F">对象</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashSet&lt;String&gt; hs = <strong><span style="color:#7F0055">new</span></strong> HashSet&lt;String&gt;();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#3F7F5F">//</span><span style="font-family:宋体;color:#3F7F5F">给集合中添加自定义对象</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hs.add(<span style="color:#2A00FF">“zhangsan”</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hs.add(<span style="color:#2A00FF">“lisi”</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hs.add(<span style="color:#2A00FF">“wangwu”</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hs.add(<span style="color:#2A00FF">“zhangsan”</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#3F7F5F">//</span><span style="font-family:宋体;color:#3F7F5F">取出集合中的每个元素</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator&lt;String&gt; it = hs.iterator();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><span style="color:#7F0055">while</span></strong>(it.hasNext()){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String s = it.next();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em><span style="color:#0000C0">out</span></em>.println(s);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p style="text-indent:28px"><span style="font-family:宋体">输出结果如下，说明集合中不能存储重复元素：</span></p><p style="text-align:left;text-indent:28px;text-autospace:none"><span style="font-size:16px;font-family:Consolas;color:black">wangwu</span></p><p style="text-align:left;text-indent:28px;text-autospace:none"><span style="font-size:16px;font-family:Consolas;color:black">lisi</span></p><p style="text-indent:28px"><span style="font-size:16px;font-family:Consolas;color:black">zhangsan</span></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">2.4<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>HashSet<span style="font-family:华文楷体">存储自定义类型元素</span></h2><p style="text-indent:28px"><span style="font-family:宋体">给</span>HashSet<span style="font-family:宋体">中存放自定义类型元素时，需要重写对象中的</span>hashCode<span style="font-family:宋体">和</span>equals<span style="font-family:宋体">方法，建立自己的比较方式，才能保证</span>HashSet<span style="font-family:宋体">集合中的对象唯一</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>创建自定义对象Student</p><p><strong>publicclass</strong><span style="color:black"> Student {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><strong>private</strong><span style="color:black"> String </span><span style="color:#0000C0">name</span><span style="color:black">;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><strong>privateint</strong><span style="color:#0000C0">age</span><span style="color:black">;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><strong>public</strong><span style="color:black"> Student(String name, </span><strong>int</strong><span style="color:black"> age) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>super</strong><span style="color:black">();</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>this</strong><span style="color:black">.</span><span style="color:#0000C0">name</span><span style="color:black"> = name;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>this</strong><span style="color:black">.</span><span style="color:#0000C0">age</span><span style="color:black"> = age;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><strong>public</strong><span style="color:black"> String getName() {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>return</strong><span style="color:#0000C0">name</span><span style="color:black">;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><strong>publicvoid</strong><span style="color:black"> setName(String name) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>this</strong><span style="color:black">.</span><span style="color:#0000C0">name</span><span style="color:black"> = name;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><strong>publicint</strong><span style="color:black"> getAge() {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>return</strong><span style="color:#0000C0">age</span><span style="color:black">;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><strong>publicvoid</strong><span style="color:black"> setAge(</span><strong>int</strong><span style="color:black"> age) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>this</strong><span style="color:black">.</span><span style="color:#0000C0">age</span><span style="color:black"> = age;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><span style="color:#646464">@Override</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><strong>public</strong><span style="color:black"> String toString() {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>return</strong><span style="color:#2A00FF">“Student [name=”</span><span style="color:black"> + </span><span style="color:#0000C0">name</span><span style="color:black"> + </span><span style="color:#2A00FF">“, age=”</span><span style="color:black"> + </span><span style="color:#0000C0">age</span><span style="color:black"> + </span><span style="color:#2A00FF">“]”</span><span style="color:black">;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><span style="color:#646464">@Override</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><strong>publicint</strong><span style="color:black"> hashCode() {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>finalint</strong><span style="color:black"> prime = 31;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>int</strong><span style="color:black"> result = 1;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = prime <em> result + </em></span><span style="color:#0000C0">age</span><span style="color:black">;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result = prime  result + ((</span><span style="color:#0000C0">name</span><span style="color:black"> == </span><strong>null</strong><span style="color:black">) ? 0 : </span><span style="color:#0000C0">name</span><span style="color:black">.hashCode());</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>return</strong><span style="color:black"> result;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><span style="color:#646464">@Override</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span><strong>publicboolean</strong><span style="color:black"> equals(Object obj) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>if</strong><span style="color:black"> (</span><strong>this</strong><span style="color:black"> == obj)</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>returntrue</strong><span style="color:black">;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>if</strong><span style="color:black">(!(obj </span><strong>instanceof</strong><span style="color:black"> Student)){</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>System.out.println(</strong><span style="color:#2A00FF">“</span><span style="font-family:宋体;color:#2A00FF">类型错误</span><span style="color:#2A00FF">“</span><strong>)</strong><span style="color:black">;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>returnfalse</strong><span style="color:black">;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Student other = (Student) obj;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>returnthis</strong><span style="color:black">.</span><span style="color:#0000C0">age</span><span style="color:black"> ==&nbsp; other.</span><span style="color:#0000C0">age</span><span style="color:black">&amp;&amp;</span><strong>this</strong><span style="color:black">.</span><span style="color:#0000C0">name</span><span style="color:black">.equals(other.</span><span style="color:#0000C0">name</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">}</span></p><p style="text-indent:0"><br></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>创建HashSet集合，存储Student对象。</p><p><strong><span style="color:#7F0055">publicclass</span></strong> HashSetDemo {</p><p>&nbsp;&nbsp;&nbsp; <strong><span style="color:#7F0055">publicstaticvoid</span></strong> main(String[] args) {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#3F7F5F">//</span><span style="font-family:宋体;color:#3F7F5F">创建</span><span style="color:#3F7F5F">HashSet</span><span style="font-family:宋体;color:#3F7F5F">对象</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashSet hs = <strong><span style="color:#7F0055">new</span></strong> HashSet();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#3F7F5F">//</span><span style="font-family:宋体;color:#3F7F5F">给集合中添加自定义对象</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hs.add(<strong><span style="color:#7F0055">new</span></strong> Student(<span style="color:#2A00FF">“zhangsan”</span>,21));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hs.add(<strong><span style="color:#7F0055">new</span></strong> Student(<span style="color:#2A00FF">“lisi”</span>,22));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hs.add(<strong><span style="color:#7F0055">new</span></strong> Student(<span style="color:#2A00FF">“wangwu”</span>,23));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hs.add(<strong><span style="color:#7F0055">new</span></strong> Student(<span style="color:#2A00FF">“zhangsan”</span>,21));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:#3F7F5F">//</span><span style="font-family:宋体;color:#3F7F5F">取出集合中的每个元素</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator it = hs.iterator();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><span style="color:#7F0055">while</span></strong>(it.hasNext()){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Student s = (Student)it.next();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em><span style="color:#0000C0">out</span></em>.println(s);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p style="text-indent:28px"><span style="font-family:宋体">输出结果如下，说明集合中不能存储重复元素：</span></p><p style="text-indent:28px">Student [name=lisi, age=22]</p><p style="text-indent:28px">Student [name=zhangsan, age=21]</p><p style="text-indent:28px">Student [name=wangwu, age=23]</p><h1 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">第3章<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">判断集合元素唯一的原理</span></h1><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">3.1<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ArrayList<span style="font-family:华文楷体">的</span>contains<span style="font-family:华文楷体">方法判断元素是否重复原理</span></h2><p><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132963257174.png" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132963257174.png" alt="7.PNG"></p><p style="text-indent:28px">ArrayList<span style="font-family:宋体">的</span>contains<span style="font-family:宋体">方法调用时</span>,<span style="font-family:宋体">会使用传入的元素的</span>equals<span style="font-family:宋体">方法依次与集合中的旧元素所比较，从而根据返回的布尔值判断是否有重复元素。此时，当</span>ArrayList<span style="font-family:宋体">存放自定义类型时，由于自定义类型在未重写</span>equals<span style="font-family:宋体">方法前，判断是否重复的依据是地址值，所以如果想根据内容判断是否为重复元素，需要重写元素的</span>equals<span style="font-family:宋体">方法。</span></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">3.2<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>HashSet<span style="font-family:华文楷体">的</span>add/contains<span style="font-family:华文楷体">等方法判断元素是否重复原理</span></h2><p><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132975224675.png" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190110/1547132975224675.png" alt="8.PNG">​</p><p style="text-indent:28px">Set<span style="font-family:宋体">集合不能存放重复元素，其添加方法在添加时会判断是否有重复元素，有重复不添加，没重复则添加。</span></p><p style="text-indent:28px">HashSet<span style="font-family:宋体">集合由于是无序的，其判断唯一的依据是元素类型的</span>hashCode<span style="font-family:宋体">与</span>equals<span style="font-family:宋体">方法的返回结果。规则如下：</span></p><p style="text-indent:28px"><span style="font-family:宋体">先判断新元素与集合内已经有的旧元素的</span>HashCode<span style="font-family:宋体">值</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>如果不同，说明是不同元素，添加到集合。</p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>如果相同，再判断equals比较结果。返回true则相同元素；返回false则不同元素，添加到集合。</p><p style="text-indent:28px"><span style="font-family:宋体">所以，使用</span>HashSet<span style="font-family:宋体">存储自定义类型，如果没有重写该类的</span>hashCode<span style="font-family:宋体">与</span>equals<span style="font-family:宋体">方法，则判断重复时，使用的是地址值，如果想通过内容比较元素是否相同，需要重写该元素类的</span>hashcode<span style="font-family:宋体">与</span>equals<span style="font-family:宋体">方法。</span></p><h1 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">第4章<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span>Collection<span style="font-family:宋体">总结</span></h1><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">4.1<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">知识点总结</span></h2><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Collection:</p><p style="text-indent:0">&nbsp;&nbsp;&nbsp; |- List 可以存储重复元素,有序的(元素存取顺序),有索引</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; |- ArrayList</p><p style="margin-left:0;text-indent:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- LinkedList</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- Set 不能存储重复元素,无序的(元素存取顺序,LinkedHashSet是有序的),无索引</p><p style="text-indent:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- HashSet</p><p style="margin-left:0;text-indent:0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |- LinkedHashSet</p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Collection方法：</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>boolean add(Object e) 把给定的对象添加到当前集合中</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>void clear() 清空集合中所有的元素</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>boolean remove(Object o) 把给定的对象在当前集合中删除</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>boolean contains(Object o) 判断当前集合中是否包含给定的对象</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>boolean isEmpty() 判断当前集合是否为空</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Iterator iterator() 迭代器，用来遍历集合中的元素的</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>int size() 返回集合中元素的个数</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Object[] toArray() 把集合中的元素，存储到数组中</p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Iterator :&nbsp; 迭代器</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Object next()返回迭代的下一个元素</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>boolean hasNext()如果仍有元素可以迭代，则返回 true。</p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>List与Set集合的区别？</p><p style="text-indent:28px">List:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">它是一个有序的集合</span>(<span style="font-family:宋体">元素存与取的顺序相同</span>)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">它可以存储重复的元素</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">它是一个无序的集合</span>(<span style="font-family:宋体">元素存与取的顺序可能不同</span>)</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">它不能存储重复的元素</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>List集合中的特有方法(下标)</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>void add(int index, Object element) 将指定的元素，添加到该集合中的指定位置上</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Object get(int index)返回集合中指定位置的元素。</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Object remove(int index) 移除列表中指定位置的元素, 返回的是被移除的元素</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Object set(int index, Object element)用指定元素替换集合中指定位置的元素,返回值的更新前的元素</p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>ArrayList:</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">底层数据结构是数组，查询快，增删慢</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">线程不安全，效率高</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>LinkedList:</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">底层数据结构是链表，查询慢，增删快</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">线程不安全，效率高</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>泛型： 用来约束数据的数据类型</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>泛型的格式：</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<span style="font-family:宋体">数据类型</span>&gt;</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">泛型可以使用在</span> <span style="font-family:宋体">类，接口，方法上</span></p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>泛型的好处</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A:<span style="font-family:宋体">提高了程序的安全性</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B:<span style="font-family:宋体">将运行期遇到的问题转移到了编译期</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C:<span style="font-family:宋体">省去了类型强转的麻烦</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>增强for:在循环的过程中不能修改集合的长度</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">简化数组和</span>Collection<span style="font-family:宋体">集合的遍历</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">格式：</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(<span style="font-family:宋体">元素数据类型</span> <span style="font-family: 宋体">变量</span> : <span style="font-family:宋体">数组或者</span>Collection<span style="font-family:宋体">集合</span>) {</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">使用变量即可，该变量就是元素</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p style="text-indent:28px">&nbsp;&nbsp; &nbsp; <span style="font-family:宋体">好处：简化遍历</span>(<span style="font-family:宋体">语法糖</span>)</p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>HashSet:</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">元素唯一不能重复</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">底层结构是</span> <span style="font-family:宋体">哈希表结构</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">元素的存与取的顺序不能保证一致</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>LinkedHashSet:</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">元素唯一不能重复</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">底层结构是</span> <span style="font-family:宋体">链表结构</span>+<span style="font-family:宋体">哈希表结构</span> </p><p style="text-indent:28px">+ &nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">元素的存与取的顺序一致</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">如何保证元素的唯一的？</span></p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">重写</span>hashCode() <span style="font-family:宋体">与</span> equals()<span style="font-family:宋体">方法</span></p><p style="text-indent:28px"><br></p><section class="_editor"><p><br></p></section>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/10/集合【LinkedList、HashSet、Collection集合体系】/" data-id="cjr6j5m09000cikotosu8dz08" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-集合" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/09/集合/" class="article-date">
  <time datetime="2019-01-09T12:48:36.000Z" itemprop="datePublished">2019-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/09/集合/">集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p></p><p><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547036868408921.png" alt="8.PNG" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547036868408921.png"></p><section class="_editor"><p><span style="font-family:宋体">第</span>7<span style="font-family:宋体">天</span> <span style="font-family:宋体">集合</span></p><p><span style="font-size:21px">今日学习内容</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight: normal">Collection</span><span style="font-size:14px;font-family:宋体;font-weight:normal">集合 </span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight: normal">Iterator</span><span style="font-size:14px;font-family:宋体;font-weight:normal">迭代器</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">增强for循环</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">泛型</span></p><p><span style="font-size:21px">今日学习目标</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">能够说出集合与数组的区别</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">说出Collection集合的常用功能</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">能够使用迭代器对集合进行取元素</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">能够说出集合的使用细节</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">能够使用集合存储自定义类型</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">能够使用foreach循环遍历集合</span></p><p><span style=";font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">能够使用泛型定义集合对象</span></p><p><span style="font-family:Wingdings;font-weight:normal">u </span><span style="font-size:14px;font-family:宋体;font-weight:normal">能够阐述泛型通配符的作用</span></p><h1 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">第1章<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">集合</span></h1><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">1.1<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">集合</span></h2><h3 style="margin-left: 64px; font-weight: bold; font-size: 16px; line-height: 1.6em;">1.1.1<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:黑体">集合介绍</span></h3><p style="text-indent:28px"><span style="font-family:宋体">前面的学习，我们知道数据多了，使用数组存放。而且数组中存放的都是基本类型的数据，并且数组是定长的。</span></p><p style="text-indent:28px"><br></p><p style="text-indent:28px"><span style="font-family:宋体">当在程序中创建的对象比较多的时候，需要对这些对象进行统一的管理和操作，那么首先我们就需要把这些对象存储起来。使用数组是可以存放对象的，我们可以定义对象数组来存放，但是数组这个容器存放对象，要对其中的对象进行更复杂操作时，数据就显的很麻烦。那怎么办呢？</span></p><p style="text-indent:28px">Java<span style="font-family:宋体">中给我们提供了另外一类容器，专门用来存放对象，这个容器就是我们要学习的集合。</span></p><p style="text-indent:28px"><span style="font-family:宋体">集合和数组既然都是容器，它们有啥区别呢？</span></p><p style="text-indent:28px"><span style="font-family:宋体;color:red">数组的长度是固定的。集合的长度是可变的。</span></p><p style="text-indent:28px"><span style="font-family:宋体">数组中存储的是同一类型的元素，可以存储基本数据类型值。</span></p><p style="text-indent:28px"><span style="font-family:宋体">集合存储的都是对象。而且对象的类型可以不一致。</span>ArrayList&lt;Object&gt;</p><p style="text-indent:28px"><span style="font-family:宋体">集合貌似看起来比较强大，它啥时用呢？</span></p><p style="text-indent:28px"><br></p><p style="text-indent:28px"><span style="font-family:宋体">当对象多的时候，先进行存储。</span></p><h3 style="margin-left: 64px; font-weight: bold; font-size: 16px; line-height: 1.6em;">1.1.2<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:黑体">集合框架的由来</span></h3><p style="text-indent:28px"><span style="font-family:宋体">集合本身是一个工具，它存放在</span>java.util<span style="font-family:宋体">包中。</span></p><p style="text-indent:28px">JDK<span style="font-family:宋体">最早的</span>1.0<span style="font-family:宋体">版本中。提供的集合容器很少</span>Vector<span style="font-family:宋体">。升级到</span>1.2<span style="font-family:宋体">版，为了更多的需求，出现了集合框架。有了更多的容器</span>(<span style="font-family:宋体">为什么提供那么多集合容器呢</span>?)<span style="font-family:宋体">。可以完成不同的需求。</span></p><p style="text-indent:28px"><span style="font-family:宋体">这些容器怎么区分？区分的方式：每一个容器的数据结构</span>(<span style="font-family:宋体">数据存储一种方式</span>)<span style="font-family:宋体">不一样。</span></p><p style="text-indent:28px"><br></p><p style="text-indent:28px"><span style="font-family:宋体">例如</span>:<span style="font-family:宋体">水缸和衣柜</span>,<span style="font-family:宋体">饮料瓶等等</span>.</p><p style="text-indent:28px"><br></p><p style="text-indent:28px"><span style="font-family:宋体">不同的容器进行不断的向上抽取，最后形成了一个集合框架，这个框架就是</span>Collection<span style="font-family:宋体">接口</span>(<span style="font-family:宋体">一会可以看一下</span>API)<span style="font-family:宋体">。在</span>Collection<span style="font-family:宋体">接口定义着集合框架中最最最共性的内容。</span></p><p style="text-indent:28px"><span style="font-family:宋体">在学习时：我们需要看最顶层怎么用，</span> <span style="font-family:宋体">创建底层对象即可。因为底层继承了父类中的所有功能。</span></p><h3 style="margin-left: 64px; font-weight: bold; font-size: 16px; line-height: 1.6em;">1.1.3<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:黑体">接口的描述</span></h3><p style="text-indent:28px"><span style="font-family:宋体">既然</span>Collection<span style="font-family:宋体">接口是集合中的顶层接口，那么它中定义的所有功能子类都可以使用。查阅</span>API<span style="font-family:宋体">中描述的</span>Collection<span style="font-family:宋体">接口。</span>Collection <span style="font-family:宋体">层次结构</span> <span style="font-family:宋体">中的根接口。</span>Collection <span style="font-family:宋体">用来存储一组对象，这些对象也称为</span> collection <span style="font-family:宋体">的元素。一些</span> collection <span style="font-family:宋体">允许有重复的元素，而另一些则不允许。</span></p><p style="text-indent:28px"><span style="font-family:宋体">一些</span> collection <span style="font-family:宋体">是有序的，而另一些则是无序的。</span></p><p style="text-indent:28px"><span style="font-family:宋体">其实我们在使用</span>ArrayList<span style="font-family:宋体">类时，该类已经把所有抽象方法进行了重写。那么，实现</span>Collection<span style="font-family:宋体">接口的所有子类都会进行方法重写。</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Collecton接口常用的子接口有：List接口(列表)、Set接口(集)</p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>List接口常用的子类有：ArrayList类、LinkedList类&nbsp;</p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>Set接口常用的子类有：HashSet类、LinkedHashSet类</p><p style="text-indent:28px"><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037540478641.png" alt="9.PNG" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037540478641.png"></p><p style="text-indent:28px"><span style="font-family:宋体">继续查阅</span>API<span style="font-family:宋体">，发现</span>Collection<span style="font-family:宋体">接口中很多集合的操作方法，那么这些方法都具体能做什么呢？</span></p><h3 style="margin-left: 64px; font-weight: bold; font-size: 16px; line-height: 1.6em;">1.1.4<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Collection<span style="font-family:黑体">基本方法了解</span></h3><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">1.2<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Collection<span style="font-family:华文楷体">接口的基本方法</span></h2><p><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037556431422.png" alt="10.PNG" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037556431422.png"></p><p style="text-indent:28px"><span style="font-family:宋体;background:white;background:white">这里我们不关心具体创建的</span><span style="background:white;background:white">Collection</span><span style="font-family:宋体;background:white;background:white">中的那个子类对象，这里重点演示的是</span><span style="background:white;background:white">Collection</span><span style="font-family:宋体;background:white;background:white">接口中的方法</span></p><p>Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();</p><p>//1,<span style="font-family:宋体">往集合中添加对象元素。</span>add(Object);</p><p>coll<span style="color:black">.add(</span><span style="color:#2a00ff">“itcast1”</span><span style="color:black">);</span></p><p>coll<span style="color:black">.add(</span><span style="color:#2a00ff">“itcast2”</span><span style="color:black">);</span></p><p>coll<span style="color:black">.add(</span><span style="color:#2a00ff">“itcast3”</span><span style="color:black">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p>//2,<span style="font-family:宋体">删除。</span></p><p>coll<span style="color:black">.remove(</span><span style="color:#2a00ff">“itcast2”</span><span style="color:black">);&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p>//3,<span style="font-family:宋体">判断是否包含。</span></p><p><span style="color:black">System.</span><em><span style="color:#0000c0">out</span></em><span style="color:black">.println(</span>coll<span style="color:black">.contains(</span><span style="color:#2a00ff">“itcast11”</span><span style="color:black">));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p>//4,<span style="font-family:宋体">清除。</span></p><p>coll<span style="color:black">.clear();</span></p><p>//<span style="font-family:宋体">把集合打印一下。</span></p><p><span style="color:black">System.</span><em><span style="color:#0000c0">out</span></em><span style="color:black">.println(</span>coll<span style="color:black">);</span>//[itcast1, itcast2, itcast3]</p><p style="margin-left:28px"><br></p><h1 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">第2章<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span>Iterator<span style="font-family:宋体">迭代器</span></h1><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">2.1<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Iterator<span style="font-family:华文楷体">迭代器概述</span></h2><p style="text-indent:28px">java<span style="font-family:宋体">中提供了很多个集合，它们在存储元素时，采用的存储方式不同。我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。</span></p><p style="text-indent:28px"><span style="color:red">Collection</span><span style="font-family:宋体;color:red">集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</span></p><p style="text-indent:28px"><span style="font-family:宋体">我们来画图描述一下迭代器的作用</span>.</p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">2.2<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Iterator<span style="font-family:华文楷体">迭代方式的代码体现</span></h2><p style="text-indent:28px"><br></p><p style="text-indent:28px"><span style="font-family:宋体">在</span>Collection<span style="font-family:宋体">接口描述了一个抽象方法</span>iterator<span style="font-family:宋体">方法，所有</span>Collection<span style="font-family:宋体">子类都实现了这个方法，并且有自己的迭代形式。</span></p><p style="text-indent:28px"><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037585211750.png" alt="11.PNG" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037585211750.png"></p><p style="text-indent:28px"><span style="font-family:宋体">集合中把这种取元素的方式描述在</span>Iterator<span style="font-family:宋体">接口中。</span>Iterator<span style="font-family:宋体">接口的常用方法如下：</span></p><p style="text-indent:28px"><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037594493066.png" alt="12.PNG" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037594493066.png"></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>hasNext（）方法：用来判断集合中是否有下一个元素可以迭代。如果返回true,说明可以迭代。</p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>next（）方法：用来返回迭代的下一个元素，并把指针向后移动一位。</p><p><br></p><p style="text-indent:28px"><span style="font-family:宋体">进行代码演示：</span></p><p>//1<span style="font-family:宋体">，创建集合对象。</span></p><p><span style="color:black">Collection&lt;String&gt; coll = </span><strong><span style="color:#7f0055">new</span></strong><span style="color:black"> ArrayList&lt;String&gt;();</span></p><p><span style="color:black">coll.add(</span><span style="color:#2a00ff">“abc1”</span><span style="color:black">);</span></p><p><span style="color:black">coll.add(</span><span style="color:#2a00ff">“abc2”</span><span style="color:black">);</span></p><p><span style="color:black">coll.add(</span><span style="color:#2a00ff">“abc3”</span><span style="color:black">);</span></p><p><span style="color:black">coll.add(</span><span style="color:#2a00ff">“abc4”</span><span style="color:black">);</span></p><p><br></p><p>//2.<span style="font-family:宋体">获取容器的迭代器对象。通过</span>iterator<span style="font-family:宋体">方法。</span></p><p>Iterator it = coll.iterator();</p><p><br></p><p>//3,<span style="font-family:宋体">使用具体的迭代器对象获取集合中的元素。参阅迭代器的方法</span></p><p>while(it.hasNext()){</p><p>&nbsp;&nbsp;&nbsp; System.out.println(it.next());</p><p>}</p><p><br></p><p><span style="color:black">/<em> </em></span></p><p style="text-indent:28px"><span style="font-family:宋体;color:black">迭代器</span><span style="color:black">for</span><span style="font-family:宋体;color:black">循环的形式的使用</span></p><p><strong><span style="color:#7f0055">for</span></strong><span style="color:black"> (Iterator it = coll.iterator(); it.hasNext();&nbsp; ) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; System.</span><em><span style="color:#0000c0">out</span></em><span style="color:black">.println(it.next());</span></p><p><span style="color:black">}</span></p><p><span style="color:black">/</span></p><p style="text-indent:28px"><span style="font-family:宋体">注意：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的</span>next<span style="font-family:宋体">方法，将会发生</span>java.util.NoSuchElementException<span style="font-family: 宋体">没有集合元素的错误。</span></p><p style="text-indent:28px"><br></p><p><strong>迭代集合元素图解：</strong></p><p style="text-indent:28px"><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037639330421.png" alt="13.PNG" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037639330421.png"></p><p style="text-indent:28px"><br></p><p style="text-indent:28px"><span style="font-family:宋体">下边分别介绍以上内容：</span></p><p>a)<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span>Collection<span style="font-family:黑体">接口的</span>iterator</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">方法声明为：</span></p><p style="margin-left:56px;text-indent:28px">Iterator&lt;<span style="font-family:宋体">集合中数据类型</span>&gt; iterator()</p><p style="text-indent:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">用来返回专属于该集合对象的迭代器对象</span>(Iterator<span style="font-family:宋体">的子类对象</span>)<span style="font-family:宋体">。</span></p><p>b)<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span>Iterator<span style="font-family:黑体">接口</span></p><pre>该接口规定了迭代集合所需要的方法<br></pre> <p>c)<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>Iterator<span style="font-family:黑体">接口的两个方法：</span>hasNext<span style="font-family:黑体">与</span>next<span style="font-family:黑体">方法</span></p><p style="margin-left:56px">Iterator<span style="font-family:宋体">规定了两个方法，集合对象产生的迭代器对象正是通过这两个方法帮助集合进行迭代工作的。</span></p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">调用迭代器的</span>hasNext<span style="font-family:宋体">方法判断是否有下一个元素</span></p><p>调用迭代器的next获取下一个元素</p><p style="margin-left:56px"><br></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">2.3<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">并发修改异常</span></h2><p style="text-indent:28px"><span style="font-family:宋体">举例</span>:</p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">使用</span>Iterator<span style="font-family:宋体">对象或者增强</span>for<span style="font-family:宋体">循环遍历集合</span>,<span style="font-family:宋体">如果出现</span>”itcast”<span style="font-family:宋体">字符串</span>,<span style="font-family:宋体">那么向集合中添加一个大写的</span>”ITCAST”<span style="font-family:宋体">字符串</span></p><p style="text-indent:28px"><br></p><p style="text-indent:28px"><span style="font-family:宋体">迭代的常规用法中我们要尽量避免在迭代过程中为集合添加</span>/<span style="font-family:宋体">删除数据。否则会报错，原因是</span>Java<span style="font-family:宋体">抛出了并发修改异常。</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p style="text-indent:28px"><span style="font-family:宋体">迭代过程中并发修改异常的原因为</span>:</p><p style="margin-left:56px;text-indent:28px"><span style="font-family:宋体">迭代器中</span><span style="color:#c00000">”</span><span style="font-family:宋体;color:#c00000">记忆</span><span style="color:#c00000">”</span><span style="font-family:宋体;color:#c00000">的集合长度与集合中实际长度不同</span><span style="font-family:宋体">，而导致出现索引与实际元素不符甚至无限循环的情况发生。</span></p><p style="text-indent:28px"><span style="font-family:宋体">所以在使用</span>Iterator<span style="font-family:宋体">时，避免类似操作，</span>for<span style="font-family:宋体">循环底层为迭代器实现，所以也需要避免类似操作。</span></p><p style="text-indent:28px"><span style="font-family:宋体">有些迭代器避免了这样的问题，如</span>ListIterator<span style="font-family:宋体">，但该类并不通用也不常用，实际开发中很少使用，只需要简单了解。</span></p><p><br></p><p style="text-indent:28px">java<span style="font-family:宋体">中提供了很多个集合，它们在存储元素时，采用的存储方式不同。我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。</span></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">2.4<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">增强</span>for<span style="font-family:华文楷体">循环</span> </h2><p style="text-indent:28px"><span style="font-family:宋体">增强</span>for<span style="font-family:宋体">循环是</span>JDK1.5<span style="font-family:宋体">以后出来的一个高级</span>for<span style="font-family:宋体">循环，专门用来遍历数组和集合的。它的内部原理其实是个</span>Iterator<span style="font-family:宋体">迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</span></p><p style="text-indent:28px"><span style="font-family:宋体">格式：</span></p><p><span style="color:red">for(</span><span style="font-family:宋体;color:red">元素的数据类型</span><span style="color:red">&nbsp; </span><span style="font-family:宋体;color:red">变量</span><span style="color:red"> : Collection</span><span style="font-family:宋体;color:red">集合</span><span style="color:red">or</span><span style="font-family:宋体;color:red">数组</span><span style="color:red">){</span></p><p><span style="color:red">}</span></p><p style="text-indent:28px"><span style="font-family:宋体">它用于遍历</span>Collection<span style="font-family:宋体">和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</span></p><p><span style="font-family:宋体">练习一：遍历数组</span></p><p>int[] arr = new int[]{11,22,33};</p><p>for (int n : arr) {//<span style="font-family:宋体">变量</span>n<span style="font-family:宋体">代表被遍历到的数组元素</span></p><p>&nbsp;&nbsp;&nbsp; System.out.println(n);</p><p>}</p><p><br></p><p><span style="font-family:宋体">练习二</span>:<span style="font-family:宋体">遍历集合</span></p><p>Collection&lt;String&gt; coll = <span style="color:#7f0055">new</span> ArrayList&lt;String&gt;();</p><p>coll.add(<span style="color:#2a00ff">“itcast1”</span>);</p><p>coll.add(<span style="color:#2a00ff">“itcast2”</span>);</p><p>coll.add(<span style="color:#2a00ff">“itcast3”</span>);</p><p>coll.add(<span style="color:#2a00ff">“itcast4”</span>);</p><p><span style="color:#7f0055">for</span>(String str : coll){<span style="color:#3f7f5f">//</span><span style="font-family: 宋体;color:#3f7f5f">变量</span><span style="color:#3f7f5f">Str</span><span style="font-family:宋体;color:#3f7f5f">代表被遍历到的集合元素</span></p><p>&nbsp;&nbsp;&nbsp; System.<em><span style="color:#0000c0">out</span></em>.println(str);</p><p>}</p><p style="text-indent:28px"><span style="font-family:宋体">增强</span>for<span style="font-family:宋体">循环和老式的</span>for<span style="font-family:宋体">循环有什么区别？</span></p><p style="text-indent:28px"><span style="font-family:宋体">注意：新</span>for<span style="font-family:宋体">循环必须有被遍历的目标。目标只能是</span>Collection<span style="font-family:宋体">或者是数组。</span></p><p style="text-indent:28px"><span style="font-family:宋体">建议：遍历数组时，如果仅为遍历，可以使用增强</span>for<span style="font-family:宋体">如果要对数组的元素进行</span> <span style="font-family:宋体">操作，使用老式</span>for<span style="font-family:宋体">循环可以通过角标操作。</span></p><h1 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">第3章<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">泛型</span></h1><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">3.1<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">泛型概述</span></h2><p style="text-indent:28px"><span style="font-family:宋体">泛型</span>:<span style="font-family:宋体">泛泛的类型</span>,<span style="font-family:宋体">就是一种<span style="color:red">不确定的类型</span></span>(JDK1.5<span style="font-family:宋体">的一个新特性</span>)</p><p style="text-indent:28px"><span style="font-family:宋体">基本体现</span>: &lt;E&gt;<span style="font-family:宋体">这就是泛型</span>,<span style="font-family:宋体">此处的</span>E<span style="font-family:宋体">是什么数据类型</span>?</p><p><br></p><p style="text-indent:28px"><span style="font-family:宋体">泛型用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数传递。</span></p><p style="text-indent:28px"><span style="font-family:宋体">泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</span></p><p style="text-indent:28px"><span style="font-family:宋体">泛型的定义：定义泛型可以在类中预支地使用未知的类型。</span></p><p style="text-indent:28px"><span style="font-family:宋体">泛型的使用：一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为</span>Object<span style="font-family:宋体">类型。</span></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">3.2<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">使用泛型的好处</span></h2><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>避免了类型强转的麻烦。</p><p style="margin-left:28px"><span style="font-family:宋体">演示下列代码：</span></p><p><strong><span style="color:#7f0055">publicclass</span></strong> GenericDemo {</p><p>&nbsp;&nbsp;&nbsp;&nbsp; /<em></em></p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <span style="font-family:宋体">使用集合对象存储并遍历</span></p><p>&nbsp;&nbsp;&nbsp; &nbsp;<em>&nbsp; <span style="font-family:宋体">不使用泛型</span> &lt;&gt; <span style="font-family:宋体">不写</span></em></p><p>&nbsp;&nbsp;&nbsp; &nbsp;/</p><p>&nbsp;&nbsp;&nbsp; public static void demo01(){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<span style="font-family:宋体">创建集合对象</span>,<span style="font-family: 宋体">不使用泛型</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<span style="font-family:宋体">没有明确集合存储的数据类型是什么</span>, <span style="font-family:宋体">什么都能存</span> Object</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList array = new ArrayList();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array.add(“abc”);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array.add(123);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator it = array.iterator();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(it.hasNext()){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //<span style="font-family:宋体">迭代器的方法</span>next()<span style="font-family:宋体">返回值是什么</span> Object</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //System.out.println(it.next());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String s = (String)it.next();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(s);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp;&nbsp; /<em></em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">使用泛型</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>/</em></p><p>&nbsp;&nbsp;&nbsp; <strong><span style="color:#7f0055">publicstaticvoid</span></strong> demo02() {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Collection&lt;String&gt; list = <strong><span style="color:#7f0055">new</span></strong> ArrayList&lt;String&gt;();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(<span style="color:#2a00ff">“abc”</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.add(<span style="color:#2a00ff">“itcast”</span>);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color:red">//list.add(5);//</span><span style="font-family:宋体;color:red">当集合明确类型后，存放类型不一致就会编译报错</span></p><p><span style="color:red">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //</span><span style="font-family:宋体;color:red">集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iterator&lt;String&gt; it = list.iterator();</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong><span style="color:#7f0055">while</span></strong>(it.hasNext()){</p><p style="text-indent:112px">&nbsp;&nbsp;&nbsp; String str = it.next();</p><p style="text-indent:112px"><span style="color:red">//</span><span style="font-family:宋体;color:red">当使用</span><span style="color:red">Iterator&lt;String&gt;</span><span style="font-family:宋体;color:red">控制元素类型后，就不需要强转了。获取到的元素直接就是</span><span style="color:red">String</span><span style="font-family:宋体;color:red">类型</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.<em><span style="color:#0000c0">out</span></em>.println(str.length());</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p style="background:#cfcdcd"><br></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">3.3<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">泛型的定义与使用</span></h2><p style="text-indent:28px"><br></p><p style="text-indent:28px"><span style="font-family:宋体">我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</span></p><p style="text-indent:28px"><span style="font-family:宋体">泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</span></p><h3 style="margin-left: 64px; font-weight: bold; font-size: 16px; line-height: 1.6em;">3.3.1<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:黑体">泛型中</span>E<span style="font-family:黑体">的含义</span></h3><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">我们以</span>ArrayList&lt;E&gt;<span style="font-family:宋体">为例</span>:</p><p style="margin-left:56px;text-indent:28px"><span style="font-family:宋体">类名</span>:ArrayList&lt;E&gt;</p><p style="margin-left:56px;text-indent:28px"><span style="font-family:宋体">方法</span>:</p><p style="margin-left:84px;text-indent:28px">boolean add(E e);</p><p style="margin-left:84px;text-indent:28px">E get(int index)</p><p style="margin-left:56px;text-indent:28px"><span style="font-family:宋体">画图说明</span>:</p><p><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037761382066.png" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037761382066.png" alt="14.PNG"></p><h3 style="margin-left: 64px; font-weight: bold; font-size: 16px; line-height: 1.6em;">3.3.2<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:黑体">含有泛型的类</span>:<span style="font-family:黑体">泛型类</span></h3><p style="margin-left:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体;color:red">定义格式：修饰符</span><span style="color:red"> class </span><span style="font-family:宋体;color:red">类名</span><span style="color:red">&lt;</span><span style="font-family:宋体;color:red">代表泛型的变量</span><span style="color:red">&gt; {&nbsp; }</span></p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>例如，API中的ArrayList集合：</p><p>class ArrayList<strong><span style="color:red">&lt;E&gt;</span></strong>{</p><p>public boolean <strong>add</strong>(<strong><span style="color:red">E</span></strong>&nbsp;e){ }</p><p>&nbsp;&nbsp;&nbsp; public <strong><span style="color:red">E</span>get</strong>(int&nbsp;index){&nbsp; }</p><p>}</p><p style="text-indent:0"><br></p><p style="margin-left:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体;color:red">使用格式：创建对象时，确定泛型的类型</span></p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>例如，ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</p><p style="text-indent:0">此时，变量E的值就是String类型</p><p>class ArrayList<strong><span style="color:red">&lt;String&gt;</span></strong>{</p><p>public boolean <strong>add</strong>(<strong><span style="color:red">String</span></strong>&nbsp;e){ }</p><p>&nbsp;&nbsp;&nbsp; public <strong><span style="color:red">String</span>get</strong>(int&nbsp;index){&nbsp; }</p><p>}</p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>例如，ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</p><p style="text-indent:0">此时，变量E的值就是Integer类型</p><p>class ArrayList<strong><span style="color:red">&lt;Integer&gt;</span></strong>{</p><p>public boolean <strong>add</strong>(<strong><span style="color:red">Integer</span></strong>&nbsp;e){ }</p><p>&nbsp;&nbsp;&nbsp; public <strong><span style="color:red">Integer</span>get</strong>(int&nbsp;index){&nbsp; }</p><p>}</p><p style="margin-left:0;text-indent:0">举例自定义泛型类</p><p style="text-align:left;background:#d8d8d8"><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicclass</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> GenericClass&lt;E&gt;{</span><span style="font-size: 12px;font-family:Consolas;color:black">//</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">自定义的类中,可以写&lt;&gt;泛型</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas">&nbsp;&nbsp; //</span><span style="font-size: 12px;font-family:Consolas;color:#3f7f5f">E </span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">表示未知的数据类型 调用者创建对象的时候,才能明确数据类型</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">private</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> E </span><span style="font-size:12px;font-family: Consolas;color:#0000c0">e</span><span style="font-size:12px;font-family:Consolas;color:black">;</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicvoid</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> setE(E e){</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">this</span></strong><span style="font-size:12px;font-family:Consolas;color:black">.</span><span style="font-size:12px;font-family:Consolas;color:#0000c0">e</span><span style="font-size:12px;font-family:Consolas;color:black"> = e;</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; }</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">public</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> E getE(){</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">return</span></strong><span style="font-size:12px;font-family:Consolas;color:#0000c0">e</span><span style="font-size:12px;font-family: Consolas;color:black">;</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; }</span></p><p style="margin-left:0;text-indent:0;background: #d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">}</span></p><p style="margin-left:0;text-indent:0;background: #d8d8d8"><span style="font-size:12px;color:black">使用</span><span style="font-size:12px;font-family:Consolas;color:black">:</span></p><p style="text-align:left;background:#d8d8d8"><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicclass</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> GenericClassTest {</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicstaticvoid</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> main(String[] args) {</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">//</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">对自定义的泛型类,进行测试</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenericClass&lt;Integer&gt; g = </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">new</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> GenericClass&lt;Integer&gt;();&nbsp; </span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //E</span><span style="font-size:12px;font-family:宋体;color:black">传递什么类型就是什么类型</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setE(100);&nbsp;&nbsp;&nbsp; </span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Integer i = g.getE();&nbsp;&nbsp; </span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.</span><em><span style="font-size:12px;font-family:Consolas;color:#0000c0">out</span></em><span style="font-size:12px;font-family:Consolas;color:black">.println(i);</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; }</span></p><p style="margin-left:0;text-indent:0;background: #d8d8d8"><span style="font-size:16px;font-family:Consolas;color:black">}</span></p><h3 style="margin-left: 64px; font-weight: bold; font-size: 16px; line-height: 1.6em;">3.3.3<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:黑体">含有泛型的方法</span></h3><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体;color:red">定义格式：修饰符</span><span style="color:red"> &lt;</span><span style="font-family:宋体;color:red">代表泛型的变量</span><span style="color:red">&gt; </span><span style="font-family:宋体;color:red">返回值类型</span> <span style="font-family: 宋体;color:red">方法名</span><span style="color:red">(</span><span style="font-family:宋体;color:red">参数</span><span style="color:red">){&nbsp; }</span></p><p><span style="font-family:宋体">例如，</span></p><p style="text-align:left;background:#bfbfbf"><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicclass</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> GenericMethod &lt;E&gt;{</span></p><p style="text-align:left;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicvoid</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> show</span><span style="font-size:12px;font-family: Consolas;color:black">1</span><span style="font-size:12px;font-family:Consolas;color:black">(E e){</span></p><p style="text-align:left;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.</span><em><span style="font-size:12px;font-family:Consolas;color:#0000c0">out</span></em><span style="font-size:12px;font-family:Consolas;color:black">.println(e);</span></p><p style="text-align:left;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; }</span></p><p style="text-align:left;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span></p><p style="text-align:left;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">pu</span></strong><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">blic</span></strong><strong> </strong><span style="font-size:12px;font-family:Consolas;color:black">&lt;T&gt;</span> <strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">void</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> show</span><span style="font-size:12px;font-family: Consolas;color:black">2</span><span style="font-size:12px;font-family:Consolas;color:black">(T t){</span><span style="font-size:12px;font-family: Consolas;color:black">//</span><span style="font-size: 12px;font-family:Consolas;color:#3f7f5f">自定义泛型的方法</span></p><p style="text-align:left;text-indent:24px;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">//</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">自己写一个方法,方法中的数据类型,采用&lt;&gt;泛型</span></p><p style="text-align:left;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp;&nbsp;&nbsp; //</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">如果方法中的泛型,和类上的泛型不同</span></p><p style="text-align:left;text-indent:24px;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">// </span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">在方法返回值前加入&lt;&gt;</span></p><p style="text-align:left;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.</span><em><span style="font-size:12px;font-family:Consolas;color:#0000c0">out</span></em><span style="font-size:12px;font-family:Consolas;color:black">.println(t);</span></p><p style="text-align:left;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; }</span></p><p style="text-align:left;background:#bfbfbf"><span style="font-size:12px;font-family:Consolas;color:black">}</span></p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体;color:red">使用格式：调用方法时，确定泛型的类型</span></p><p style="text-align:left;background:#d8d8d8"><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicclass</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> GenericMethodTest {</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicstaticvoid</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> main(String[] args) {</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GenericMethod&lt;Double&gt; g = </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">new</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> GenericMethod&lt;Double&gt;();</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.show(1.1);</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.function(1.2F);</span><span style="font-size:12px;font-family:Consolas;color:black">//</span><span style="font-size:12px;font-family:宋体;color:black">传递什么类型就是什么类型</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; }</span></p><p style="margin-left:0;text-indent:0;background: #d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">}</span></p><h3 style="margin-left: 64px; font-weight: bold; font-size: 16px; line-height: 1.6em;">3.3.4<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:黑体">含有泛型的接口</span></h3><p style="margin-left:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体;color:red">定义格式：修饰符</span><span style="color:red"> interface</span><span style="font-family:宋体;color:red">接口名</span><span style="color:red">&lt;</span><span style="font-family:宋体;color:red">代表泛型的变量</span><span style="color:red">&gt; {&nbsp; }</span></p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>例如，</p><p style="text-align:left;background:#d8d8d8"><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicinterface</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> Inter &lt;</span><span style="font-size:12px;font-family:Consolas;color:black">E</span><span style="font-size:12px;font-family:Consolas;color:black">&gt;{</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicabstractvoid</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> show(</span><span style="font-size:12px;font-family: Consolas;color:black">E</span><span style="font-size:12px;font-family:Consolas;color:black"> e);</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">}</span></p><p style="margin-left:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p style="margin-left:28px"><span style="font-family:宋体;color:red">使用格式：</span></p><p style="margin-left:28px;text-indent:28px"><span style="color:red">1</span><span style="font-family:宋体;color:red">、实现接口时</span><span style="color:red">,</span><span style="font-family:宋体;color:red">确定泛型的类型</span></p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>例如</p><p style="text-align:left;background:#d8d8d8"><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicclass</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> InterImpl </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">implements</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> Inter&lt;Integer&gt;{</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicvoid</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> show(Integer i){</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.</span><em><span style="font-size:12px;font-family:Consolas;color:#0000c0">out</span></em><span style="font-size:12px;font-family:Consolas;color:black">.println(i);</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; }</span></p><p style="background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">}</span></p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">此时，变量</span>E<span style="font-family:宋体">的值就是</span><span style="font-size:12px;font-family:Consolas;color:black">Integer</span><span style="font-family:宋体">类型。</span></p><p><br></p><p style="text-indent:56px"><span style="color:red">2</span><span style="font-family:宋体;color:red">、实现接口</span><span style="color:red">,</span><span style="font-family:宋体;color:red">不指定泛型的类型，直到创建对象时，确定泛型的类型</span></p><p style="margin-left:84px"><span style="font-family:Wingdings">n<span style="font:9px 'Times New Roman'">&nbsp; </span></span>例如</p><p style="margin-left:84px"><span style="font-size:12px;font-family:Consolas;color:black">InterImpl</span>&lt;String&gt; imp= new <span style="font-size:12px;font-family:Consolas;color:black">InterImpl</span>&lt;String&gt;();</p><p style="text-indent:0">此时，变量E的值就是<strong>String</strong>类型。</p><p style="text-align:left;background:#d8d8d8"><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicclass</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> InterImpl&lt;E&gt;</span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">implements</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> Inter&lt;E&gt;{</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicvoid</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> show(E e){</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.</span><em><span style="font-size:12px;font-family:Consolas;color:#0000c0">out</span></em><span style="font-size:12px;font-family:Consolas;color:black">.println(e);</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; }</span></p><p style="text-align:left;background:#d8d8d8"><span style="font-size:12px;font-family:Consolas;color:black">}</span></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">3.4<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">泛型通配符</span></h2><p style="text-indent:28px"><span style="font-family:宋体">当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符</span>&lt;?&gt;<span style="font-family:宋体">表示。但是一旦使用泛型的通配符后，只能使用</span>Object<span style="font-family:宋体">类中的共性方法，集合中元素自身方法无法使用。</span></p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">定义：</span>(<span style="font-family:宋体">查看</span>ArrayList<span style="font-family:宋体">的构造方法或者</span>addAll<span style="font-family:宋体">方法</span>)<span style="font-family:宋体">无法在类中使用</span></p><p style="margin-left:20px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">使用：调用方法时可以给予任意类型。参照</span>Arraylist<span style="font-family:宋体">的构造方法或者</span>addAll<span style="font-family:宋体">方法</span></p><p style="margin-left:68px;text-indent:16px">? extends E<span style="font-family: 宋体">代表只要是</span>E<span style="font-family:宋体">类型的子类即可</span></p><p style="margin-left:68px;text-indent:16px">? super E<span style="font-family: 宋体">代表只要是</span>E<span style="font-family:宋体">类型的父类即可</span></p><p style="text-indent:28px"><br></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:13px;font-family:Consolas;color:#3f7f5f">/</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f"></span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp;<em> </em></span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">泛型通配符?,代表任意的数据类型</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp; </span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp;<em> </em></span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">定义：(查看ArrayList的</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">addAll</span><span style="font-size:12px;font-family: Consolas;color:#3f7f5f">)</span><span style="font-size: 12px;font-family:Consolas;color:#3f7f5f">无法在类中使用</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp; </span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp;<em> </em></span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">使用：调用方法时可以给予任意类型。参照<span style="text-decoration:underline;">Arraylist</span>的</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">add</span><span style="font-size:12px;font-family:宋体;color:#3f7f5f">方法</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp; public</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f"> boolean addAll</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">(Collection&lt;? extends E&gt; c)</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp;<em> </em></span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">为了便于?的理解,我们将以上方法重写为public</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f"> boolean</span> <span style="font-size:12px;font-family: Consolas;color:#3f7f5f">addAll</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">(ArrayList&lt;? extends E&gt; c)</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp; </span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp;<em> </em></span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">该方法的意思:集合对象A</span><span style="font-size:12px;font-family:宋体;color:#3f7f5f">调用</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">addAll</span><span style="font-size:12px;font-family:宋体;color:#3f7f5f">方法</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">,</span><span style="font-size:12px;font-family:宋体;color:#3f7f5f">将</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">一个集合对象B作为参数,</span><span style="font-size:12px;font-family:宋体;color:#3f7f5f">即向</span><span style="font-size: 12px;font-family:Consolas;color:#3f7f5f">集合A中</span><span style="font-size:12px;font-family:宋体;color:#3f7f5f">添加</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">集合B中的元素</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp; </span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp;<em> ? extends E</em></span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">代表只要是E类型的子类即可</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp; ? super E</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">代表只要是E类型的父类即可</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">&nbsp;*/</span></p><p style="text-align:left;background:#cfcdcd"><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicclass</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> Demo01 {</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">publicstaticvoid</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> main(String[] args) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">//</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">定义集合b,包含3个元素</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList&lt;String&gt; listB = </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">new</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> ArrayList&lt;String&gt;();</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listB.add(</span><span style="font-size:12px;font-family:Consolas;color:#2a00ff">“Jack”</span><span style="font-size:12px;font-family:Consolas;color:black">);</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listB.add(</span><span style="font-size:12px;font-family:Consolas;color:#2a00ff">“Rose”</span><span style="font-size:12px;font-family:Consolas;color:black">);</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listB.add(</span><span style="font-size:12px;font-family:Consolas;color:#2a00ff">“Trump”</span><span style="font-size:12px;font-family:Consolas;color:black">);</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">//</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">使用集合b创建集合a</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList&lt;Object&gt; listA = </span><strong><span style="font-size:12px;font-family:Consolas;color:#7f0055">new</span></strong><span style="font-size:12px;font-family:Consolas;color:black"> ArrayList&lt;Object&gt;();</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listA.add(</span><span style="font-size:12px;font-family:Consolas;color:#2a00ff">“Obama”</span><span style="font-size:12px;font-family:Consolas;color:black">);</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listA.addAll(listB);</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">//</span><span style="font-size:12px;font-family:Consolas;color:#3f7f5f">观察集合A</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.</span><em><span style="font-size:12px;font-family:Consolas;color:#0000c0">out</span></em><span style="font-size:12px;font-family:Consolas;color:black">.println(listA);</span></p><p style="text-align:left;background:#cfcdcd"><span style="font-size:12px;font-family:Consolas;color:black">&nbsp;&nbsp;&nbsp; }</span></p><p style="text-align:left;background:#cfcdcd"><br></p><h1 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">第4章<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:宋体">集合综合案例</span></h1><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">4.1<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">案例介绍</span></h2><p style="margin-left:28px"><span style="font-family:宋体">按照斗地主的规则，完成洗牌发牌的动作。</span></p><p style="margin-left:28px"><span style="font-family:宋体">具体规则：</span></p><p style="margin-left:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">使用</span>54<span style="font-family:宋体">张牌</span></p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">打乱顺序</span></p><p style="margin-left:28px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family:宋体">三个玩家参与游戏，三人交替摸牌，每人</span>17<span style="font-family:宋体">张牌，最后三张留作底牌。</span></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">4.2<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">案例需求分析</span></h2><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>准备牌：</p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">牌可以设计为一个</span>ArrayList&lt;String&gt;,<span style="font-family:宋体">每个字符串为一张牌。</span></p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。</span></p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">牌由</span>Collections<span style="font-family:宋体">类的</span>shuffle<span style="font-family:宋体">方法进行随机排序。</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>发牌：</p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">将每个人以及底牌设计为</span>ArrayList&lt;String&gt;,<span style="font-family:宋体">将最后</span>3<span style="font-family:宋体">张牌直接存放于底牌，剩余牌通过对</span>3<span style="font-family:宋体">取模依次发牌。</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>看牌：</p><p style="margin-left:28px;text-indent:28px"><span style="font-family:宋体">直接打印每个集合。</span></p><p><br></p><h2 style="font-weight: bold; font-size: 16px; line-height: 1.6em;">4.3<span style="font:9px 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:华文楷体">实现代码步骤</span></h2><p style="margin-left:28px"><span style="font-size:16px"><img src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037820315987.png" _src="http://bj96weixin-1252078571.file.myqcloud.com/ueditor/20190109/1547037820315987.png" alt="15.PNG">​</span></p><p style="text-indent:28px"><span style="font-family:宋体">修改文件编码由</span>GBK<span style="font-family:宋体">修改为</span>UTF-8<span style="font-family:宋体">，因为</span>GBK<span style="font-family:宋体">没有我们要的梅花、方片、黑桃、红桃</span>(<span style="font-family:'Arial','sans-serif'">♠♥♦♣</span>)<span style="font-family:宋体">等字符。</span></p><p>publicclass<span style="color:black"> Poker {</span></p><p><br></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; </span>publicstaticvoid<span style="color:black"> main(String[] args) {</span></p><p><br></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//♠♥♦♣</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">准备牌</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList&lt;String&gt; poker = </span>new<span style="color:black"> ArrayList&lt;String&gt;();</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">花色</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList&lt;String&gt; color = </span>new<span style="color:black"> ArrayList&lt;String&gt;();</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color.add(</span><span style="color:#2a00ff">“♠”</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color.add(</span><span style="color:#2a00ff">“♥”</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color.add(</span><span style="color:#2a00ff">“♦”</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color.add(</span><span style="color:#2a00ff">“♣”</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">数字</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList&lt;String&gt; number = </span>new<span style="color:black"> ArrayList&lt;String&gt;();</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>for<span style="color:black"> (</span>int<span style="color:black"> i = 2; i &lt;= 10; i++) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number.add(i+</span><span style="color:#2a00ff">“”</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number.add(</span><span style="color:#2a00ff">“J”</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number.add(</span><span style="color:#2a00ff">“Q”</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; number.add(</span><span style="color:#2a00ff">“K”</span><span style="color:black">);</span></p><p><span style="color:black">number.add(</span><span style="color:#2a00ff">“A”</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">完成新牌</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>for<span style="color:black"> (String thisColor : color) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>for<span style="color:black"> (String thisNumber : number) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String thisCard = thisColor + thisNumber;</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poker.add(thisCard);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poker.add(</span><span style="color:#2a00ff">“</span><span style="font-family:宋体;color:#2a00ff">小</span><span style="color:#2a00ff">☺”</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poker.add(</span><span style="color:#2a00ff">“</span><span style="font-family:宋体;color:#2a00ff">大</span><span style="color:#2a00ff">☻”</span><span style="color:black">);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">洗牌</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Collections.<em>shuffle</em>(poker);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">发牌</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">玩家</span><span style="color:#3f7f5f">1</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList&lt;String&gt; player1 = </span>new<span style="color:black"> ArrayList&lt;String&gt;();&nbsp;&nbsp;&nbsp; </span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">玩家</span><span style="color:#3f7f5f">2</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList&lt;String&gt; player2 = </span>new<span style="color:black"> ArrayList&lt;String&gt;();</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">玩家</span><span style="color:#3f7f5f">3</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList&lt;String&gt; player3 = </span>new<span style="color:black"> ArrayList&lt;String&gt;();</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">底牌</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ArrayList&lt;String&gt; secretCards = </span>new<span style="color:black"> ArrayList&lt;String&gt;();</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>for<span style="color:black"> (</span>int<span style="color:black"> i = 0; i &lt; poker.size(); i++) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if<span style="color:black">(i&gt;=51) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">最后三张发给底牌</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secretCards.add(poker.get(i));</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span>else<span style="color:black"> {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">剩余牌通过对</span><span style="color:#3f7f5f">3</span><span style="font-family:宋体;color:#3f7f5f">取模依次摸牌</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if<span style="color:black">(i%3==0) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player1.add(poker.get(i));</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span>elseif<span style="color:black">(i%3==1) {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player2.add(poker.get(i));</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span>else<span style="color:black"> {</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; player3.add(poker.get(i));</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:#3f7f5f">//</span><span style="font-family:宋体;color:#3f7f5f">看牌</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; System.</span><em><span style="color:#0000c0">out</span></em><span style="color:black">.println(player1);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.</span><em><span style="color:#0000c0">out</span></em><span style="color:black">.println(player2);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.</span><em><span style="color:#0000c0">out</span></em><span style="color:black">.println(player3);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.</span><em><span style="color:#0000c0">out</span></em><span style="color:black">.println(secretCards);</span></p><p><span style="color:black">&nbsp;&nbsp;&nbsp; }</span></p><p><span style="color:black">}</span></p><p><span style="font-family:Wingdings">l<span style="font:9px 'Times New Roman'">&nbsp; </span></span>最后发到三个人手中的牌是无序的，在明天学习完Map集合后，我们提供一个排序的解决方案。</p><p><br></p><p><br></p></section><section class="_editor"><p><br></p></section><p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/09/集合/" data-id="cjr6j5m0g000fikotb9qu22il" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-常用API" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/常用API/" class="article-date">
  <time datetime="2019-01-08T14:52:18.000Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/08/常用API/">常用API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第6天常用API</p>
<p>今日内容介绍</p>
<p>u 正则表达式</p>
<p>u Date</p>
<p>u DateFormat</p>
<p>u Calendar</p>
<p>u 基本类型包装类</p>
<p>u System</p>
<p>u Math</p>
<p>今日学习目标</p>
<p>u 能够理解正则表达式验证11位手机号码</p>
<p>u 能够理解正则表达式验证QQ号码</p>
<p>u 能够使用日期类输出当前的日期</p>
<p>u 能够说出将日期格式化成字符串的方法</p>
<p>u 说出将字符串转换成日期的方法</p>
<p>u 写出基本数据类型对应的八种包装类</p>
<p>u 写出字符串转换成基本数据类型的方法</p>
<p>u 写出基本数据类型转换成字符串方式</p>
<p>u 能够说出拆箱装箱概念</p>
<p>u 能够掌握System类常见方法的使用</p>
<p>u 能够使用Math类进行数学运算<br>第1章  Date<br>1.1      Date类概述</p>
<p>类 Date 表示特定的瞬间，精确到毫秒。</p>
<p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。<br><img src="https://i.imgur.com/IfK5Fm0.png" alt=""></p>
<p>//创建日期对象，把当前的毫秒值转成日期对象</p>
<p>Date date = new Date(1607616000000L);</p>
<p>System.out.println(date);</p>
<p>//打印结果：Fri Dec 11 00:00:00 CST 2020</p>
<p>可是将毫秒值转成日期后，输出的格式不利于我们阅读，继续查阅API，Date中有getYear、getMouth等方法，可以他们已经过时，继续往下查阅，看到了toString方法。</p>
<p><img src="https://i.imgur.com/BItHXLI.png" alt=""></p>
<p>点开toString()方法查阅，原来上面打印的date对象就是默认调用了这个toString方法.<br>1.2      Date类常用方法</p>
<p><img src="https://i.imgur.com/0iQ7NEA.png" alt=""><br>l  把日期对象转换成对应的时间毫秒值</p>
<p>l  毫秒值是不断变化的,所以每次打印的不一样,金钱买不了时间<br>第2章  DateFormat<br>2.1      DateFormat类概述</p>
<p>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat类）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。</p>
<p>我们通过这个类可以帮我们完成日期和文本之间的转换。</p>
<p>继续阅读API，DateFormat 可帮助进行格式化并解析任何语言环境的日期。对于月、星期，甚至日历格式（阴历和阳历），其代码可完全与语言环境的约定无关。<br>2.2      日期格式</p>
<p>要格式化一个当前语言环境下的日期也就是日期 -&gt; 文本），要通过下面的方法来完成。DateFormat是抽象类，我们需要使用其子类SimpleDateFormat来创建对象。</p>
<p>l  构造方法<br><img src="https://i.imgur.com/Dy3RU2q.png" alt=""></p>
<p>l  DateFormat类方法<br><img src="https://i.imgur.com/csnADBT.png" alt=""></p>
<p>代码演示：</p>
<p>//创建日期格式化对象,在获取格式化对象时可以指定风格</p>
<p>DateFormat df= new SimpleDateFormat(“yyyy-MM-dd”);//对日期进行格式化</p>
<p>Date date = new Date(1607616000000L);</p>
<p>String str_time = df.format(date);</p>
<p>System.out.println(str_time);//2020年12月11日</p>
<p>l  DateFormat类的作用：即可以将一个Date对象转换为一个符合指定格式的字符串，也可以将一个符合指定格式的字符串转为一个Date对象。</p>
<p>指定格式的具体规则我们可参照SimpleDateFormat类的说明，这里做简单介绍，规则是在一个字符串中，会将以下字母替换成对应时间组成部分，剩余内容原样输出：</p>
<p>l  当出现y时，会将y替换成年</p>
<p>l  当出现M时，会将M替换成月</p>
<p>l  当出现d时，会将d替换成日</p>
<p>l  当出现H时，会将H替换成时</p>
<p>l  当出现m时，会将m替换成分</p>
<p>l  当出现s时，会将s替换成秒<br>2.3      DateFormat类常用方法<br><img src="https://i.imgur.com/LcKDr1Y.png" alt=""></p>
<p>l  format方法，用来将Date对象转换成String</p>
<p>l  parse方法，用来将String转换成Date（转换时，该String要符合指定格式，否则不能转换）。</p>
<p>代码演示：</p>
<p>练习一：把Date对象转换成String</p>
<pre><code> Date date = new Date(1607616000000L);//Fri Dec 11 00:00:00 CST 2020

DateFormat df = new SimpleDateFormat(“yyyy年MM月dd日”);

String str = df.format(date);

//str中的内容为2020年12月11日
</code></pre><p>练习二：把String转换成Date对象</p>
<pre><code>String str = ”2020年12月11日”;

DateFormat df = new SimpleDateFormat(“yyyy年MM月dd日”);

Date date = df.parse( str );

//Date对象中的内容为Fri Dec 11 00:00:00 CST 2020
</code></pre><p>第3章     Calendar<br>3.1      Calendar类概念</p>
<p>Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</p>
<p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，将语言敏感内容处理好，再返回子类对象，如下：</p>
<p>l  Calendar类静态方法<br><img src="https://i.imgur.com/3pnpDVr.png" alt=""></p>
<p>Calendar c = Calendar.getInstance();  //返回当前日历对象</p>
<p>Syso(c);//我们可以打印出来 看一下,东西很多不必要挨个研究</p>
<p>public static Calendar getInstance(){</p>
<p>Calendar c = new GregorianCalendar();</p>
<pre><code>return c;
</code></pre><p>}</p>
<p>3.2      Calendar类常用方法<br><img src="https://i.imgur.com/XIUhVVb.png" alt=""></p>
<p>l  public static Calendar getInstance() //获取日期对象</p>
<p>l  public int get(int field)   //获取时间字段值，字段参见帮助文档</p>
<p>n  YEAR 年</p>
<p>n  MONTH 月，从0开始算起，最大11；0代表1月，11代表12月。</p>
<p>n  DATE 天</p>
<p>n  HOUR 时</p>
<p>n  MINUTE分</p>
<p>n  SECOND秒</p>
<p>代码演示：</p>
<pre><code>Calendar c = Calendar.getInstance();

int year = c.get(Calendar.YEAR);
</code></pre><p>//做一个小练习 打印当前时间:xxxx年xx月xx日(注意月份的时间???)</p>
<p>l  public final void set(int field,int value)//设置指定字段的值</p>
<p>代码演示：</p>
<pre><code>Calendar c = Calendar.getInstance();

//设置时间为2020年5月20日

c.set(Calendar.YEAR, 2020);

c.set(Calendar.MONTH, 4);

c.set(Calendar.DATE, 20);
</code></pre><p>l  public final Date getTime()    //获取该日历对象转成的日期对象</p>
<p>代码演示：</p>
<pre><code>Calendar c = Calendar.getInstance();

Date d = c.getTime();
</code></pre><p>3.3      注意事项</p>
<p>西方星期的开始为周日，中国为周一。</p>
<p>在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>日期是有大小关系的，时间靠后，时间越大。<br>第4章  System类<br>4.1      概念</p>
<p>在API中System类介绍的比较简单，我们给出定义，System中代表程序所在系统，提供了对应的一些系统属性信息，和系统操作。</p>
<p>查看文档System类不能手动创建对象，因为构造方法被private修饰，阻止外界创建对象。System类中的都是static方法，类名访问即可。在JDK中，有许多这样的类。<br>4.2      常用方法(arraycopy)<br><img src="https://i.imgur.com/2BZK6bA.png" alt=""></p>
<p>l  currentTimeMillis()   获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p>
<p>l  exit(int status) 用来结束正在运行的Java程序。参数传入一个数字即可。通常传入0记为正常状态，其他为异常状态</p>
<p>l  gc() 用来运行JVM中的垃圾回收器，完成内存中垃圾的清除。</p>
<p>l  getProperty(String key) 用来获取指定键(字符串名称)中所记录的系统属性信息</p>
<p>l <img src="https://i.imgur.com/vAumYr6.png" alt=""></p>
<p>l <img src="https://i.imgur.com/jyPhbfU.png" alt=""><br>第5章  Math类<br>5.1      概念</p>
<p>Math 类是包含用于执行基本数学运算的方法的数学工具类，如初等指数、对数、平方根和三角函数。</p>
<p>类似这样的工具类，其所有方法均为静态方法，并且一般不会创建对象。如System类</p>
<p>5.2      常用方法<br><img src="https://i.imgur.com/4GuEUNn.png" alt=""><br>l  abs方法,结果都为正数</p>
<p>double d1 = Math.abs(-5); // d1的值为5</p>
<p>double d2 = Math.abs(5); // d2的值为5</p>
<p>l  ceil方法，结果为比参数值大的最小整数的double值</p>
<p>double d1 = Math.ceil(3.3); //d1的值为 4.0</p>
<p>double d2 = Math.ceil(-3.3); //d2的值为 -3.0</p>
<p>double d3 = Math.ceil(5.1); // d3的值为 6.0</p>
<p>l  floor方法，结果为比参数值小的最大整数的double值</p>
<p>double d1 = Math.floor(3.3); //d1的值为3.0</p>
<p>double d2 = Math.floor(-3.3); //d2的值为-4.0</p>
<p>double d3 = Math.floor(5.1); //d3的值为 5.0</p>
<p>l  max方法，返回两个参数值中较大的值</p>
<p>double d1 = Math.max(3.3, 5.5); //d1的值为5.5</p>
<p>double d2 = Math.max(-3.3, -5.5); //d2的值为-3.3</p>
<p>l  min方法，返回两个参数值中较小的值</p>
<p>double d1 = Math.min(3.3, 5.5); //d1的值为3.3</p>
<p>double d2 = Math.max(-3.3, -5.5); //d2的值为-5.5</p>
<p>l  pow方法，返回第一个参数的第二个参数次幂的值</p>
<p>double d1 = Math.pow(2.0, 3.0); //d1的值为 8.0</p>
<p>double d2 = Math.pow(3.0, 3.0); //d2的值为27.0</p>
<p>l  round方法，返回参数值四舍五入的结果</p>
<p>double d1 = Math.round(5.5); //d1的值为6.0</p>
<p>double d2 = Math.round(5.4); //d2的值为5.0</p>
<p>l  random方法，产生一个大于等于0.0且小于1.0的double小数</p>
<p>double d1 = Math.random();<br>第6章  基本类型包装类</p>
<p>大家回想下，在第二天我们学习Java中的基本数据类型时，说Java中有8种基本的数据类型，可是这些数据是基本数据，想对其进行复杂操作，变的很难。怎么办呢？<br>6.1      基本类型包装类概述</p>
<p>在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等。那么，想实现字符串与基本数据之间转换怎么办呢？</p>
<p>Java中提供了相应的对象来解决该问题，基本数据类型对象包装类：java将基本数据类型值封装成了对象。封装成对象有什么好处？可以提供更多的操作基本数值的功能。</p>
<p>8种基本类型对应的包装类如下：<br><img src="https://i.imgur.com/fuc2Pxg.png" alt=""></p>
<p>其中需要注意int对应的是Integer，char对应的Character，其他6个都是基本类型首字母大写即可。</p>
<p>基本数据类型对象包装类特点：用于在基本数据和字符串之间进行转换。</p>
<p>l  将字符串转成基本类型：<br><img src="https://i.imgur.com/tcr0CxF.png" alt=""></p>
<p>parseXXX(String s);其中XXX表示基本类型，参数为可以转成基本类型的字符串，如果字符串无法转成基本类型，将会发生数字转换的问题NumberFormatException</p>
<p>System.out.println(Integer.parseInt(“123”) + 2);</p>
<p>//打印结果为 125</p>
<p>基本类型变成String</p>
<p>基本类型+”” 就可以<br>6.2      自动装箱拆箱</p>
<p>在需要的情况下，基本类型与包装类型可以通用。有些时候我们必须使用引用数据类型时，可以传入基本数据类型。</p>
<p>比如：</p>
<pre><code>基本类型可以使用运算符直接进行计算，但是引用类型不可以。而基本类型包装类作为引用类型的一种却可以计算，原因在于，Java”偷偷地”自动地进行了对象向基本数据类型的转换。

相对应的，引用数据类型变量的值必须是new出来的内存空间地址值，而我们可以将一个基本类型的值赋值给一个基本类型包装类的引用。原因同样在于Java又”偷偷地”自动地进行了基本数据类型向对象的转换。
</code></pre><p>l  自动拆箱：对象转成基本数值</p>
<p>l  自动装箱：基本数值转成对象</p>
<p>Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);</p>
<p>i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5; 加法运算完成后，再次装箱，把基本数值转成对象。<br>第7章  正则表达式<br>7.1      正则表达式的概念</p>
<p>正则表达式（英语：Regular Expression，在代码中常简写为regex）。</p>
<p>正则表达式是一个字符串，使用单个字符串来描述、用来定义匹配规则，匹配一系列符合某个句法规则的字符串。在开发中，正则表达式通常被用来检索、替换那些符合某个规则的文本。<br>7.2      字符串类中涉及正则表达式的常用方法<br><img src="https://i.imgur.com/1wKfkLX.png" alt=""></p>
<p>l  public boolean matches(String regex) //判断字符串是否匹配给定的规则</p>
<p>举例：校验qq号码.</p>
<pre><code>1:要求必须是5-15位数字

2:0不能开头
</code></pre><p>代码演示：</p>
<pre><code>String qq = &quot;604154942&quot;;

String regex = &quot;[1-9][0-9]{4,14}&quot;;

booleanflag2 = qq.matches(regex);
</code></pre><p>举例：校验手机号码</p>
<pre><code>1：要求为11位数字
</code></pre><p>2：第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。</p>
<p>代码演示：</p>
<pre><code>String phone = &quot;18800022116&quot;;

String regex = &quot;1[34578][0-9]{9}&quot;;

booleanflag = phone.matches(regex);
</code></pre><p>l  public String[] split(String regex)  //根据给定正则表达式的匹配规则，拆分此字符串</p>
<p>举例：分割出电话号码字符串中的的数字</p>
<p>代码演示：</p>
<p>String s = “18-22-40-65”;</p>
<pre><code>String regex = &quot;-&quot;;

String[] result = s.split(regex);
</code></pre><p>代码演示：</p>
<pre><code>String s = &quot;18 22 40 65&quot;;

String regex = &quot; &quot;;

String[] result = s.split(regex);
</code></pre><p>附录(这部分内容大家知道有就可以了):正则表达式的匹配规则</p>
<p>参照帮助文档，在Pattern类中有正则表达式的的规则定义，正则表达式中明确区分大小写字母。我们来学习语法规则。</p>
<p>正则表达式的语法规则：</p>
<p>字符：x</p>
<p>含义：代表的是字符x</p>
<p>例如：匹配规则为 “a”，那么需要匹配的字符串内容就是 ”a”</p>
<p>字符：\</p>
<p>含义：代表的是斜线字符’\’</p>
<p>例如：匹配规则为”\“ ，那么需要匹配的字符串内容就是 ”\”</p>
<p>字符：\t</p>
<p>含义：制表符</p>
<p>例如：匹配规则为”\t” ，那么对应的效果就是产生一个制表符的空间</p>
<p>字符：\n</p>
<p>含义：换行符</p>
<p>例如：匹配规则为”\n”，那么对应的效果就是换行,光标在原有位置的下一行</p>
<p>字符：\r</p>
<p>含义：回车符</p>
<p>例如：匹配规则为”\r”，那么对应的效果就是回车后的效果,光标来到下一行行首</p>
<p>字符类：[abc]</p>
<p>含义：代表的是字符a、b 或 c</p>
<p>例如：匹配规则为”[abc]”，那么需要匹配的内容就是字符a，或者字符b，或字符c的一个</p>
<p>字符类：[^abc]</p>
<p>含义：代表的是除了 a、b 或 c以外的任何字符</p>
<p>例如：匹配规则为”[^abc]”，那么需要匹配的内容就是不是字符a，或者不是字符b，或不是字符c的任意一个字符</p>
<p>字符类：[a-zA-Z]</p>
<p>含义：代表的是a 到 z 或 A 到 Z，两头的字母包括在内</p>
<p>例如：匹配规则为”[a-zA-Z]”，那么需要匹配的是一个大写或者小写字母</p>
<p>字符类：[0-9]</p>
<p>含义：代表的是 0到9数字，两头的数字包括在内</p>
<p>例如：匹配规则为”[0-9]”，那么需要匹配的是一个数字</p>
<p>字符类：[a-zA-Z_0-9]</p>
<p>含义：代表的字母或者数字或者下划线(即单词字符)</p>
<p>例如：匹配规则为” [a-zA-Z_0-9] “，那么需要匹配的是一个字母或者是一个数字或一个下滑线</p>
<p>预定义字符类：.</p>
<p>含义：代表的是任何字符</p>
<p>例如：匹配规则为” . “，那么需要匹配的是一个任意字符。如果，就想使用 . 的话，使用匹配规则”\.”来实现</p>
<p>s</p>
<p>预定义字符类：\d</p>
<p>含义：代表的是 0到9数字，两头的数字包括在内，相当于[0-9]</p>
<p>例如：匹配规则为”\d “，那么需要匹配的是一个数字</p>
<p>预定义字符类：\w</p>
<p>含义：代表的字母或者数字或者下划线(即单词字符)，相当于[a-zA-Z_0-9]</p>
<p>例如：匹配规则为”\w “，，那么需要匹配的是一个字母或者是一个数字或一个下滑线</p>
<p>边界匹配器：^</p>
<p>含义：代表的是行的开头</p>
<p>例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容从[abc]这个位置开始, 相当于左双引号</p>
<p>边界匹配器：$</p>
<p>含义：代表的是行的结尾</p>
<p>例如：匹配规则为^[abc][0-9]$ ，那么需要匹配的内容以[0-9]这个结束, 相当于右双引号</p>
<p>边界匹配器：\b</p>
<p>含义：代表的是单词边界</p>
<p>例如：匹配规则为”\b[abc]\b”，那么代表的是字母a或b或c的左右两边需要的是非单词字符([a-zA-Z_0-9])</p>
<pre><code>String regex = &quot;.*\\b[abc]\\b.*&quot;;

String str = &quot;abc a bbc&quot;;

booleanflag = str.matches(regex);
</code></pre><p>数量词：X?</p>
<p>含义：代表的是X出现一次或一次也没有</p>
<p>例如：匹配规则为”a?”，那么需要匹配的内容是一个字符a，或者一个a都没有</p>
<p>数量词：X*</p>
<p>含义：代表的是X出现零次或多次</p>
<p>例如：匹配规则为”a*”，那么需要匹配的内容是多个字符a，或者一个a都没有</p>
<p>数量词：X+</p>
<p>含义：代表的是X出现一次或多次</p>
<p>例如：匹配规则为”a+”，那么需要匹配的内容是多个字符a，或者一个a</p>
<p>数量词：X{n}</p>
<p>含义：代表的是X出现恰好 n 次</p>
<p>例如：匹配规则为”a{5}”，那么需要匹配的内容是5个字符a</p>
<p>数量词：X{n,}</p>
<p>含义：代表的是X出现至少 n 次</p>
<p>例如：匹配规则为”a{5, }”，那么需要匹配的内容是最少有5个字符a</p>
<p>数量词：X{n,m}</p>
<p>含义：代表的是X出现至少 n 次，但是不超过 m 次</p>
<p>例如：匹配规则为”a{5,8}”，那么需要匹配的内容是有5个字符a 到 8个字符a之间</p>
<p>逻辑运算符：XY</p>
<p>含义：代表的是X后跟Y</p>
<p>例如：匹配规则为”ab”，那么需要匹配的字符串内容就是 ”ab”</p>
<p>逻辑运算符：X|Y</p>
<p>含义：代表的是X 或 Y</p>
<p>例如：匹配规则为”a|b”，那么需要匹配的字符串内容就是 ”a”或”b”</p>
<p>逻辑运算符：(X)</p>
<p>含义：代表的是（）括号内的数据作为一组数据出现，(X)的方式称为正则表达式中的组</p>
<p>例如：匹配规则为”(hello)+”，那么需要匹配的内容是组内数据要出现多次，如”hellohellohello”；或者组内数据出现一次，如”hello”。</p>
<p>l  注意实现：</p>
<p>n  在定义正则表达式的匹配规则字符串的里面，想再次使用组中的内容，可通过\1来进行使用</p>
<p>例如：正则表达式的匹配规则为”(a) == \1”；</p>
<p>使用数据”a == a”进行匹配结果为true；使用数据”a == b”进行匹配结果为false。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/常用API/" data-id="cjr6j5lzj0008ikotv6nmerti" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-重写、this、super-抽象类" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/05/重写、this、super-抽象类/" class="article-date">
  <time datetime="2019-01-05T12:54:21.000Z" itemprop="datePublished">2019-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/05/重写、this、super-抽象类/">重写、this、super,抽象类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>继承<br>1.1    继承中子类中出现与父类重名的成员变量</p>
<p>当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。</p>
<pre><code>在子类中，访问父类中的成员变量格式：

super.父类中的成员变量
</code></pre><p>看如下代码：<br>    class Fu<br>    {<br>    //Fu中的成员变量。<br>    int num = 5;<br>    }<br>    class Zi extends Fu<br>    {<br>    //Zi中的成员变量<br>    int num = 6;<br>    void show()<br>    {<br>        //子父类中出现了同名的成员变量时<br>        //在子类中需要访问父类中非私有成员变量时，需要使用super关键字<br>        //访问父类中的num<br>        System.out.println(“Fu num=”+super.num);<br>        //访问子类中的num2<br>        System.out.println(“Zi num2=”+this.num);<br>    }<br>    }<br>    class Demo5<br>    {<br>    public static void main(String[] args)<br>    {<br>        Zi z = new Zi(); //创建子类对象<br>        z.show(); //调用子类中的show方法<br>    }<br>    }</p>
<p>1.2    继承后子类对象的内存图</p>
<p>当子类创建对象后，该子类对象本身可以使用this来指代，而该对象当中的父类空间可以使用super来指代。</p>
<p>如下为加入了子父类关系后的对象内存图。</p>
<p>继承后对象内存图</p>
<p><img src="https://i.imgur.com/qZ5yxjO.png" alt=""></p>
<p>1.3    继承中方法重写&amp;应用</p>
<p>    子父类成员方法特殊情况——覆盖</p>
<p>子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖。</p>
<pre><code>class Fu
{
public void show()
{
    System.out.println(&quot;Fu show&quot;);
}
}
class Zi extends Fu
{
//子类复写了父类的show方法
public void show()
{
    System.out.println(&quot;Zi show&quot;);
}
}
</code></pre><p>   方法重写（覆盖）的应用：<br>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。</p>
<p>举例：比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能，后期由于手机需要在来电显示功能中增加显示姓名和头像，这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能。</p>
<p>在子类中，访问父类中的成员方法格式：<br>super.父类中的成员方法();</p>
<p>看如下代码：</p>
<pre><code>public class Test {
public static void main(String[] args) {
    new NewPhone().showNum();
}
}

//手机类
class Phone{
public void sendMessage(){
    System.out.println(&quot;发短信&quot;);
}
public void call(){
    System.out.println(&quot;打电话&quot;);
}
public void showNum(){
    System.out.println(&quot;来电显示号码&quot;);
}
}

//智能手机类
class NewPhone extends Phone{

//覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能
public void showNum(){
    //调用父类已经存在的功能使用super
    super.showNum();
    //增加自己特有显示姓名和图片功能
    System.out.println(&quot;显示来电姓名&quot;);
    System.out.println(&quot;显示头像&quot;);
}
}
</code></pre><p>1.4    方法重写的注意事项</p>
<p>重写需要注意的细节问题：</p>
<p>    子类方法覆盖/重写/覆写(override)父类方法，必须要保证权限大于等于父类权限。</p>
<pre><code>class Fu(){    
void show(){}
    public void method(){}
}
class Zi() extends Fu{
public void show(){}  //编译运行没问题
    void method(){}      //编译错误
}
</code></pre><p>    如果父类的方法是private的修饰的,那么在子类中没法重写(其他修饰符都可以重写)</p>
<p>    写法上稍微注意:必须一模一样:方法的返回值类型 方法名 参数列表都要一样。</p>
<p>总结：当一个类是另一个类中的一种时，可以通过继承，来继承属性与功能。如果父类具备的功能内容需要子类特殊定义时，进行方法重写。</p>
<p>1.5    this与super调用普通成员与构造方法</p>
<pre><code>调用普通成员：
this.成员变量       可以访问本类对象的成员变量
super.成员变量     可以访问父类对象的成员变量

this.成员方法()     可以访问本类对象的成员方法
super.成员方法()    可以访问父类对象的成员方法

使用this找本类,如果子类没有找父类
使用super找父类,如果父类没有不会去找子类

调用构造方法：
this(其他参数)      可以访问本类其他的构造方法
super(其他参数)    可以访问父类其他的构造方法

   默认子类调用父类构造方法
子类的每个构造方法中均有默认的super(),调用父类的空参构造。手动调用父类构造会覆盖默认的super();
</code></pre><p>1.6    [扩展1]使用this调用其他构造方法</p>
<pre><code>public class Person {
private int age;
public Person(){
    this(15);//这句话调用 下面带int参数构造
}
public Person(int age){
    this.age = age;
}
public int getAge() {
    return age;
}
public void setAge(int age) {
    this.age = age;
}
}
/*
 *  以前this.这种形式;
 *  现在:this() 语句形式
 *  调用本类中的其他构造方法
 *  注意:this()语句形式必须写在构造方法的第一行
 */
public class Test {
public static void main(String[] args) {
    Person p = new Person();
    int a = p.getAge();
    System.out.println(a);

/*    Person p1 = new Person(15);
    a = p1.getAge();
    System.out.println(a);*/
}
}
</code></pre><p>需求1,创建一个人的对象,要求:无论通过何种构造方法创建,人对象的年龄就是10岁.</p>
<p>1.7    [扩展2]使用super调用父类的构造方法</p>
<p>一.子类的每个每个每个构造方法中均有默认的super(),调用父类的空参构造</p>
<pre><code>public class Fu {

    public Fu(){
        System.out.println(&quot;父类的构造方法&quot;);
    }
}

public class Zi extends Fu{
int a;
    public Zi(){
        //super();
        System.out.println(&quot;子类的构造方法&quot;);
    }
public Zi(int a){
        this.a = a;
        System.out.println(&quot;子类的构造方法&quot;);
    }


}
public class Test {
    public static void main(String[] args) {
        new Zi();//匿名对象
}
}
</code></pre><p>二.  super()调用的是父类无参的构造方法  但是能不能调用父类其他有参构造呢?</p>
<pre><code>public class Fu {
int a;
    public Fu(){
        System.out.println(&quot;父类的构造方法&quot;);
    }
public Fu(int a){
        this.a = a;
    }

}

public class Zi extends Fu{
    public Zi(){
           System.out.println(&quot;子类的构造方法&quot;);
    }
}
public class Test {
    public static void main(String[] args) {
        new Zi();//匿名对象
}
}
</code></pre><p>思考:<br>Java设计的时候为什么这么干????<br>原因[了解]:<br>      Java设计的时候坚持了一个原则,谁污染谁治理,谁的孩子谁负责<br>                                    谁的成员变量 谁初始化(类不能太累,单一职责原则)</p>
<p>18.this与super</p>
<p>18.1父类对象空间优于子类对象产生</p>
<p>在每次创建子类对象时，我们均会先创建父类对象，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类对象空间，便可以包含其父类对象的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。</p>
<p>代码体现在子类的构造方法调用时，一定先调用父类的构造方法。</p>
<p>18.2继承关系图(this与super)</p>
<p>当子类创建对象后，该子类对象本身可以使用this来指代，而该对象当中的父类对象空间可以使用super来指代。</p>
<p>如下为加入了子父类关系后的对象内存图。</p>
<pre><code>以Person类为例：

//定义父类
public class Person {
    private String name;
    private int age;

    public Person(){}
    public Person(String name,int age) {
        this.name = name;
        this.age = age;
     }
    //get/set方法
 }

//定义子类
public class Chinese extends Person{
private String address;
public Chinese(){}
public Chinese(String name,int age,String address) {
    super(name,age);
    this.address = address;
}
//对address的get/set
}


//定义测试类,使用子类创建对象
public class Test{
Chinese c = new Chinese(“AngelaBaby”,18,”北京海淀区上地软件园”);
}

继承后对象内存图
</code></pre><p><img src="https://i.imgur.com/0Omzpgw.png" alt=""></p>
<p>第2章    抽象类</p>
<p>2.1    抽象类-产生</p>
<p>当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的功能具体实现方式，那么这些方法都有具体的方法体。</p>
<p>但是有的时候，某个父类只是知道子类应该包含怎么样的方法，但是无法准确知道子类如何实现这些方法。</p>
<p>比如一个图形类应该有一个求周长的方法，但是不同的图形求周长的算法不一样。那该怎么办呢？</p>
<p>再比如:动物应该有吃饭的方法,猫,狗,猪…. 那么在他们的父类中 这个吃方法应该怎么定义?</p>
<p>分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。</p>
<pre><code>如：
描述讲师的行为：工作。
描述助教的行为：工作。
描述班主任的行为：工作。
讲师、助教、班主任之间有共性，可以进行向上抽取。抽取它们的所属共性类型：员工。由于讲师、助教、班主任都具有工作功能，但是他们具体工作内容却不一样。这时在描述员工时，发现了有些功能不能够具体描述，那么，这些不具体的功能，需要在类中标识出来，通过java中的关键字abstract(抽象)修饰。
</code></pre><p>当定义了抽象函数的类也必须被abstract关键字修饰，被abstract关键字修饰的类是抽象类。</p>
<p>2.2    抽象类&amp;抽象方法的定义</p>
<p>抽象方法定义的格式：</p>
<p>public abstract 返回值类型 方法名(参数);</p>
<p>抽象类定义的格式：</p>
<pre><code>abstract class 类名 {
}
</code></pre><p>看如下代码：</p>
<pre><code>//员工
abstractclass Employee{
    public abstract void work();//抽象函数。需要abstract修饰，并分号;结束
}

//讲师
class Teacher extends Employee {
    publicvoid work() {
        System.out.println(&quot;正在讲解Java&quot;);
    }
}

//助教
class Assistant extends Employee {
    publicvoid work() {
        System.out.println(&quot;正在辅导学生&quot;);
    }
}

//班主任
class Manager extends Employee {
    publicvoid work() {
        System.out.println(&quot;正在管理班级&quot;);
    }
}
</code></pre><p>2.3    抽象类&amp;抽象方法的使用</p>
<p>抽象类无法直接创建对象，只能被子类继承后，创建子类对象。</p>
<p>子类需要继承抽象父类并完成最终的方法实现细节(即重写方法，完成方法体)。而此时，方法重写不再是加强父类方法功能，而是父类没有具体实现，子类完成了具体实现，我们将这种方法重写也叫做实现方法。</p>
<p>抽象类是拥有构造方法的，其存在的意义在于对自身进行初始化，供其子类使用。</p>
<p>2.4    抽象类常见疑惑</p>
<p>    抽象类一定可以是个父类，因为抽象类时不断抽取共性需求而来的。</p>
<p>    抽象类中是可以不定义抽象方法的，此时仅仅是不让该类创建对象，用于某些特殊的设计需要。</p>
<p>    设计时由具体类抽取出抽象类，而开发阶段应该先定义抽象父类，再根据不同需求由父类定义子类。</p>
<p>第3章    综合案例—员工类系列定义</p>
<p>3.1    案例介绍</p>
<p>某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师.</p>
<p>公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。</p>
<pre><code>    工作内容
    JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站
    Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件
    网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通
    硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机
</code></pre><p>请根据描述，完成员工体系中所有类的定义，并指定类之间的继承关系。进行XX工程师类的对象创建，完成工作方法的调用。</p>
<p>3.2    案例分析</p>
<p>    根据上述部门的描述，得出如下的员工体系图</p>
<p><img src="https://i.imgur.com/KiIbOwp.png" alt=""></p>
<p>    根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。则，把这些共同的属性与功能抽取到父类中（员工类），关于工作的内    容由具体的工程师来进行指定。</p>
<pre><code>    工作内容
    JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站
    Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件
    网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通
    硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机
</code></pre><p>    创建JavaEE工程师对象，完成工作方法的调用</p>
<p>3.3    案例代码实现</p>
<p>    根据员工体系图，完成类的定义</p>
<p>定义员工类(抽象类)</p>
<pre><code>publicabstractclass Employee {
private String id;// 员工编号
private String name; // 员工姓名

public String getId() {
    returnid;
}
publicvoid setId(String id) {
    this.id = id;
}
public String getName() {
    returnname;
}
publicvoid setName(String name) {
    this.name = name;
}

//工作方法（抽象方法）
publicabstractvoid work();
}
</code></pre><p>    定义研发部员工类Developer 继承 员工类Employee</p>
<pre><code>publicabstractclass Developer extends Employee {
}
</code></pre><p>    定义维护部员工类Maintainer 继承 员工类Employee</p>
<pre><code>publicabstractclass Maintainer extends Employee {
}
</code></pre><p>    定义JavaEE工程师 继承 研发部员工类，重写工作方法</p>
<pre><code>publicclass JavaEE extends Developer {
    @Override
    publicvoid work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝网站&quot;);
    }
}
</code></pre><p>    定义Android工程师 继承 研发部员工类，重写工作方法</p>
<pre><code>publicclass Android extends Developer {
    @Override
    publicvoid work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝手机客户端软件&quot;);
    }
}
</code></pre><p>    定义Network网络维护工程师 继承 维护部员工类，重写工作方法</p>
<pre><code>publicclass Network extends Maintainer {
@Override
publicvoid work() {
    System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在检查网络是否畅通&quot;);
}
}
</code></pre><p>    定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法</p>
<pre><code>publicclass Hardware extends Maintainer {
@Override
publicvoid work() {
    System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在修复打印机&quot;);
}
}
</code></pre><p>    在测试类中，创建JavaEE工程师对象，完成工作方法的调用</p>
<pre><code>publicclass Test {
publicstaticvoid main(String[] args) {
    //创建JavaEE工程师员工对象
    JavaEE ee = new JavaEE();
    //设置该员工的编号
    ee.setId(&quot;000015&quot;);
    //设置该员工的姓名
    ee.setName(&quot;小明&quot;);
    //调用该员工的工作方法
    ee.work();
}
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/05/重写、this、super-抽象类/" data-id="cjr6j5lyh0004ikot7dzj3wzn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面向对象" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/04/面向对象/" class="article-date">
  <time datetime="2019-01-04T03:15:30.000Z" itemprop="datePublished">2019-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/04/面向对象/">面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>什么叫面向对象编程?有人是这么理解的</p>
<p><img src="https://i.imgur.com/zJiJhR2.png" alt=""></p>
<p>也有人说不对,面向对象编程是你要编程你对象也要编程.</p>
<p><img src="https://i.imgur.com/sTlQoV2.png" alt=""></p>
<p>面向对象简称:“OOP” 面向对象编程</p>
<p>使用类映射现实生活中的事物，其功能封装为方法，属性封装为成员变量。</p>
<p>一个类拥有的成员包括：</p>
<pre><code>成员变量
构造方法
普通方法
getters/setters
</code></pre><p>如一个Person类的定义：</p>
<pre><code>class Person{
private String name;
private int age;

public Person(){}
public Person(String name,int age) {
    this.name = name;
    this.age = age;
}

public void showName() {
    System.out.println(this.name);
}
set/get方法
}
</code></pre><p>1.3    对象的内存解释</p>
<p>对象在内存中的位置：<br>对象由new关键字创建，如同数组，实体存在于堆内存中</p>
<p>任何事物均可以定义成类，创建对象，属于引用类型</p>
<p>而对象的引用变量是一个普通变量。存储的值是该对象堆内存中的地址。</p>
<p>基本类型赋值代码解释</p>
<p><img src="https://i.imgur.com/5UJAGHv.png" alt="">                         </p>
<p> 基本类型赋值对应内存图</p>
<p><img src="https://i.imgur.com/pXmLmZn.png" alt=""></p>
<p>引用类型赋值代码解释</p>
<p><img src="https://i.imgur.com/elt0Yg0.png" alt=""></p>
<p>引用类型赋值对应内存图</p>
<p><img src="https://i.imgur.com/K3xFv5k.png" alt=""></p>
<p>1.4    this关键字概念</p>
<p>this一般出现在类的一个方法当中，代表当前对象的引用。我们通常用其将本对象中的成员与其他作用域区分开来。<br>我们用代码回顾一下 this关键字的作用,用来区分成员变量和局部变量同名情况<br>当一个类定义好之后，如果不创建对象this是没有意义的。<br>一个类可以有多个对象。每个对象都有各自的属性值，各个对象的方法均是类中定义的那个方法逻辑。定义中的this就代表调用方法的这个对象。</p>
<p><img src="https://i.imgur.com/ABsvMsv.png" alt=""></p>
<p>1.5    匿名对象<br>1.5.1    匿名对象的概念<br>匿名: 不露身分、个人特征或不说明是什么人物<br>生活中有哪些匿名案例?<br>匿名账号<br><img src="https://i.imgur.com/v3lyqwK.png" alt=""></p>
<p>匿名举报</p>
<p><img src="https://i.imgur.com/t3tqkD7.png" alt=""></p>
<p>匿名对象</p>
<p><img src="https://i.imgur.com/CqBpjWE.png" alt=""></p>
<p>匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。</p>
<p>如：已经存在的类：<br>    public class Person{<br>    public void eat(){<br>        System.out.println();<br>    }<br>    }</p>
<p>创建一个普通对象<br>Person p = new Person();<br>创建一个匿名对象<br>new Person();</p>
<p>1.5.2    匿名对象的特点<br>    创建匿名对象直接使用，没有变量名。</p>
<p>new Person().eat()  //eat方法被一个没有名字的Person对象调用了。</p>
<p>    匿名对象在没有指定其引用变量时，只能使用一次。</p>
<p>new Person().eat(); 创建一个匿名对象，调用eat方法<br>new Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象</p>
<p>    匿名对象可以作为方法接收的参数、方法返回值使用</p>
<pre><code>class Demo {
publicstatic Person getPerson(){
    //普通方式
    //Person p = new Person();    
    //return p;

    //匿名对象作为方法返回值
    returnnew Person(); 
}

publicstaticvoid method(Person p){}
}

class Test {
publicstaticvoid main(String[] args) {
    //调用getPerson方法，得到一个Person对象
    Person person = Demo.getPerson();

    //调用method方法
    Demo.method(person);
    //匿名对象作为方法接收的参数
    Demo.method(new Person());
}
}
</code></pre><p>继承</p>
<p>2.1.1    继承的概念</p>
<p>什么叫继承? 他是面向对象的三大特征之一</p>
<p>现实生活中的继承  QQ:5位 12345</p>
<p><img src="https://i.imgur.com/MP1q8wV.png" alt=""></p>
<p>在现实生活中，继承一般指的是子女继承父辈的财产。</p>
<p>在程序中，继承描述的是类与类之间的关系，通过继承可以多个类之间形成一种关系体系。例如学校中的讲师、助教、班主任都属于员工。这些员工之间会形成一个继承体系，具体如下图所示。</p>
<p><img src="https://i.imgur.com/Ehedy9c.png" alt=""></p>
<p>图1-1    员工继承关系图<br>在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，<br>继承后子类的特点:<br>子类会自动拥有父类所有可继承的属性和方法。</p>
<p>思考:<br>现实生活中还有哪些继承的例子?</p>
<p>2.1.2    继承的定义及使用格式</p>
<p>在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。</p>
<p>格式：<br>class 子类 extends 父类 {}<br>接下来通过一个案例来学习子类是如何继承父类的，如下所示。Example01.java</p>
<pre><code>/*
 * 定义员工类Employee
 */
class Employee {
String name; // 定义name属性
// 定义员工的工作方法
publicvoid work() {
    System.out.println(&quot;尽心尽力地工作&quot;);
}
}

/*
 * 定义讲师类Teacher 继承 员工类Employee
 */
classTeacherextends Employee {
// 定义一个打印name的方法
publicvoid printName() {
    System.out.println(&quot;name=&quot; + name);
}
}

/*
 * 定义测试类
 */
publicclass Example01 {
publicstaticvoid main(String[] args) {
    Teachert = newTeacher (); // 创建一个讲师类对象
    t.name = &quot;小明&quot;; // 为该员工类的name属性进行赋值
    t.printName(); // 调用该员工的printName()方法
    t.work(); // 调用Developer类继承来的work()方法
}
}
</code></pre><p>运行结果如下图所示。</p>
<p> <img src="https://i.imgur.com/dZgYayg.png" alt=""><br>图1-2    运行结果</p>
<p>在上述代码中，Teacher类通过extends关键字继承了Employee类，这样Teacher类便是Employee类的子类。从运行结果不难看出，子类虽然没有定义name属性和work()方法，但是却能访问这两个成员。这就说明，子类在继承父类的时候，会自动拥有父类的成员。</p>
<p>小结:<br>继承是面向对象的核心特性，是面向对象的学习重点。<br>继承是代码复用的重要方式，是类与类之间的一种关系。</p>
<p>继承的注意事项:</p>
<p>1.继承必须合理性:(人是人他妈生的 妖是妖他妈生的)<br>从类与类之间的设计关系来看,子类必须属于父类的一种时 is a，才会继承。</p>
<p>2.父类中成员是共性的内容<br>父类抽取出了共性的内容，子类可以在父类基础上扩展新的属性与行为。</p>
<p>3.子类自动拥有父类的成员并且可以直接使用非私有的父类成员。</p>
<p>2.2    继承-子类中访问父类成员变量特点</p>
<p>了解了继承给我们带来的好处，提高了代码的复用性。继承让类与类或者说对象与对象之间产生了关系。那么，当继承出现后，类的成员之间产生了那些变化呢？</p>
<p>类的成员重点学习成员变量、成员方法的变化。</p>
<p>成员变量：如果子类父类中出现不同名的成员变量，这时的访问是没有任何问题。</p>
<p>看如下代码：</p>
<pre><code>class Fu
{
//Fu中的成员变量。
int num = 5;
}
class Zi extends Fu
{
//Zi中的成员变量
int num2 = 6;
//Zi中的成员方法
public void show()
{
    //访问父类中的num
    System.out.println(&quot;Fu num=&quot;+num);
    //访问子类中的num2
    System.out.println(&quot;Zi num2=&quot;+num2);
}
}
class Demo 
{
public static void main(String[] args) 
{
    Zi z = new Zi(); //创建子类对象
//System.out.println(z.num1);
    //z.show(); //调用子类中的show方法
}
}
</code></pre><p>代码说明：Fu类中的成员变量是非私有的，子类中可以直接访问，若Fu类中的成员变量私有了，子类是不能直接访问的。</p>
<p>2.3    继承-子类中访问父类成员方法特点</p>
<p>子父类中成员方法的特点</p>
<p>当在程序中通过对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。</p>
<p>看如下代码：</p>
<pre><code>class Fu{
public void show(){
    System.out.println(&quot;Fu类中的show方法执行&quot;);
}
}
class Zi extends Fu{
public void show2(){
    System.out.println(&quot;Zi类中的show2方法执行&quot;);
}
}
public  class Test{
public static void main(String[] args) {
    Zi z = new Zi();
    z.show(); //子类中没有show方法，但是可以找到父类方法去执行
    z.show2();
}
}
</code></pre><p>继承特点</p>
<p>1.Java只支持单继承:就一个子类  只能最多直接继承一个父类</p>
<p>2.Java支持多层继承:</p>
<p>3.父类定义了继承树中共性内容，子类定义了该类个性内容。</p>
<p>说明:在以后的开发过程中</p>
<p>我们学习了多态后，要结合多态,能使用父类时尽量使用父类，提高程序扩展性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/04/面向对象/" data-id="cjr6j5lzf0006ikottflij79f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用SpringBoot-Dubbo搭建一个简单的分布式服务" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/09/使用SpringBoot-Dubbo搭建一个简单的分布式服务/" class="article-date">
  <time datetime="2018-12-09T14:36:08.000Z" itemprop="datePublished">2018-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/09/使用SpringBoot-Dubbo搭建一个简单的分布式服务/">使用SpringBoot+Dubbo搭建一个简单的分布式服务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>目录：</p>
<pre><code>使用 SpringBoot+Dubbo 搭建一个简单分布式服务

实战之前，先来看几个重要的概念

    什么是分布式?

    什么是 Duboo？

    Dubbo 架构

    什么是 RPC？

    为什么要用 Dubbo？

开始实战 1 ：zookeeper 环境安装搭建

    1. 下载

    2. 解压

    3. 进入zookeeper目录，创建data文件夹。

    4. 进入/zookeeper/conf目录下，复制zoo_sample.cfg，命名为zoo.cfg

    5. 修改配置文件

    6. 启动测试

开始实战 2 ：实现服务接口 dubbo-interface

    1. dubbo-interface 项目创建

    2. 创建接口类

    3. 将项目打成 jar 包供其他项目使用

开始实战 3 ：实现服务提供者 dubbo-provider

    1. dubbo-provider 项目创建

    2. pom 文件引入相关依赖

    3. 在 application.properties 配置文件中配置 dubbo 相关信息

    4. 实现接口

    5. 服务提供者启动类编写

开始实战 4 ：实现服务消费者 dubbo-consumer

    4. 编写一个简单 Controller 调用远程服务

    5. 服务消费者启动类编写

    6. 测试效果
</code></pre><p>使用 SpringBoot+Dubbo 搭建一个简单分布式服务</p>
<p>实战之前，先来看几个重要的概念</p>
<p>开始实战之前，我们先来简单的了解一下这样几个概念：Dubbo、RPC、分布式、由于本文的目的是带大家使用SpringBoot+Dubbo 搭建一个简单的分布式服务，所以这些概念我只会简单给大家普及一下，不会做深入探究。</p>
<p>什么是分布式?</p>
<p>分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等。</p>
<p>我们可以使用 Dubbo作为分布式系统的桥梁，那么什么是 Dubbo 呢？</p>
<p>什么是 Duboo？</p>
<p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p>
<p>Dubbo 目前已经有接近 23k 的 Star ，Dubbo的Github 地址：<a href="https://github.com/apache/incubator-dubbo。另外，在开源中国举行的2018年度最受欢迎中国开源软件这个活动的评选中，Dubbo" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo。另外，在开源中国举行的2018年度最受欢迎中国开源软件这个活动的评选中，Dubbo</a> 更是凭借其超高人气仅次于 vue.js 和 ECharts 获得第三名的好成绩。</p>
<p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>
<p>下面我们简单地来看一下 Dubbo 的架构，加深对 Dubbo 的理解。</p>
<p>Dubbo 架构</p>
<p>下面我们再来看看 Dubbo 的架构，我们后面会使用 zookeeper 作为注册中心，这也是 Dubbo 官方推荐的一种方式。</p>
<p><img src="https://i.imgur.com/QIVeuMj.png" alt=""></p>
<p>上述节点简单说明：</p>
<pre><code>Provider 暴露服务的服务提供方

Consumer 调用远程服务的服务消费方

Registry 服务注册与发现的注册中心

Monitor 统计服务的调用次数和调用时间的监控中心

Container 服务运行容器
</code></pre><p>调用关系说明：</p>
<pre><code>服务容器负责启动，加载，运行服务提供者。

服务提供者在启动时，向注册中心注册自己提供的服务。

服务消费者在启动时，向注册中心订阅自己所需的服务。

注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。

服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。

服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。
</code></pre><p>我们在讲 Dubbo 的时候提到了 Dubbo 实际上是一款 RPC 框架，那么RPC 究竟是什么呢？相信看了下面我对 RPC 的介绍你就明白了！</p>
<p>什么是 RPC？</p>
<p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务A,B部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<p>为什么要用 Dubbo？</p>
<p>如果你要开发分布式程序，你也可以直接基于 HTTP 接口进行通信，但是为什么要用 Dubbo呢？</p>
<p>我觉得主要可以从 Dubbo 提供的下面四点特性来说为什么要用 Dubbo：</p>
<pre><code>负载均衡——同一个服务部署在不同的机器时该调用那一台机器上的服务

服务调用链路生成——服务之间互相是如何调用的

服务访问压力以及时长统计——当前系统的压力主要在哪里，如何来扩容和优化

服务降级——某个服务挂掉之后调用备用服务
</code></pre><p>开始实战 1 ：zookeeper 环境安装搭建</p>
<p>我使用的是 CentOS 7.4 阿里云服务器，注意：如果你也同样阿里云服务器必须配置一个安全组，不然你的应用程序会无法访问你的 zookeeper 服务器，这一点我在后面也提到了。</p>
<ol>
<li>下载</li>
</ol>
<p>通过 <a href="http://mirror.bit.edu.cn/apache/zookeeper/" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache/zookeeper/</a> 这个链接下载，然后上传到Linux上。（可以说那个 Xhell 附带的文件传输功能）</p>
<p><img src="https://i.imgur.com/JiTnYRa.png" alt=""></p>
<p>或者直接在Linux中使用 wget <a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.12/zookeeper-3.4.12.tar.gz" target="_blank" rel="noopener">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.12/zookeeper-3.4.12.tar.gz</a> 命令下载（版本号 3.4.12 是我写这篇文章的时候最新的稳定版本，各位可以根据实际情况修改）</p>
<ol start="2">
<li>解压</li>
</ol>
<p><img src="https://i.imgur.com/0MMAuyq.png" alt=""></p>
<p>解压完毕之后修改一下解压之后所得的文件夹名</p>
<pre><code>mv zookeeper-3.4.12 zookeeper
</code></pre><p>删除 zookeeper 安装包</p>
<pre><code>rm -rf zookeeper-3.4.12.tar.gz
</code></pre><p>3 进入zookeeper目录，创建data文件夹。</p>
<pre><code>mkdir data
</code></pre><p>进入 data 文件夹 然后执行pwd命令，复制所得的当前目录位置(就是我用红色圈出来的文字)</p>
<p><img src="https://i.imgur.com/qNSqsiT.png" alt=""></p>
<p>4 进入/zookeeper/conf目录下，复制zoo_sample.cfg，命名为zoo.cfg</p>
<pre><code>cp zoo_sample.cfg zoo.cfg
</code></pre><p>5 修改配置文件</p>
<p>使用 vim zoo.cfg 命令修改配置文件</p>
<pre><code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）
</code></pre><p>修改配置文件中的 data 属性:</p>
<p>dataDir=/usr/local/zookeeper/data</p>
<ol start="6">
<li>启动测试</li>
</ol>
<p>进入 /zookeeper/bin 目录然后执行下面的命令</p>
<p>./zkServer.sh start</p>
<p>执行 ./zkServer.sh status 查看当前 zookeeper 状态。</p>
<p>或者运行 netstat -lntup 命令查看网络状态,可以看到 zookeeper 的端口号 2181 已经被占用</p>
<p><img src="https://i.imgur.com/joBNDnS.png" alt=""></p>
<p>注意没有关闭防火墙可能出现的问题！！！</p>
<p>如果你使用的阿里云服务器注意配置相关安全组：</p>
<p>   1进入本实例安全组页面</p>
<p><img src="https://i.imgur.com/4XQbVCY.png" alt=""></p>
<p>2 选择配置规则</p>
<p><img src="https://i.imgur.com/h96YZL3.png" alt=""></p>
<p>3 选择添加安全组规则，然后按照下图配置</p>
<p><img src="https://i.imgur.com/IPLixoO.png" alt=""></p>
<p>在开始实战之前提个建议：尽量新建一个文件夹，然后后面将接口项目、服务提供者以及服务消费者都放在这个文件夹。</p>
<p><img src="https://i.imgur.com/z1KZ01T.png" alt=""></p>
<p>开始实战 2 ：实现服务接口 dubbo-interface</p>
<p>主要分为下面几步：</p>
<pre><code>1.创建 Maven 项目;

2.创建接口类

3.将项目打成 jar 包供其他项目使用
</code></pre><p>项目结构：</p>
<p><img src="https://i.imgur.com/o3h5obx.png" alt=""></p>
<p>dubbo-interface 后面被打成 jar 包，它的作用只是提供接口。</p>
<ol>
<li>dubbo-interface 项目创建</li>
</ol>
<p>File-&gt;New-&gt;Module… ,然后选择 Maven类型的项目，其他的按照提示一步一步走就好。</p>
<p><img src="https://i.imgur.com/o86q7uk.png" alt=""></p>
<p><img src="https://i.imgur.com/mDTuOpC.png" alt=""></p>
<p>2.创建接口类</p>
<p>package top.snailclimb.service;</p>
<pre><code>public interface HelloService {

public  String sayHello(String name);

}
</code></pre><p>3 将项目打成 jar 包供其他项目使用</p>
<p>点击右边的 Maven Projects 然后选择 install ，这样 jar 宝就打好了。</p>
<p><img src="https://i.imgur.com/oMi0niF.png" alt=""></p>
<p>开始实战 3 ：实现服务提供者 dubbo-provider</p>
<p>主要分为下面几步：</p>
<pre><code>1.创建 springboot 项目;

2.加入 dubbo 、zookeeper以及接口的相关依赖 jar 包；

3.在 application.properties 配置文件中配置 dubbo 相关信息；

4.实现接口类;

5.服务提供者启动类编写
</code></pre><p>项目结构：</p>
<p><img src="https://i.imgur.com/xhbmxe0.png" alt=""></p>
<ol>
<li>dubbo-provider 项目创建</li>
</ol>
<p>创建一个 SpringBoot 项目，注意勾选上 web 模块。不会创建的话，可以查看下面这篇文章：，可以说很详细了。</p>
<p><a href="https://blog.csdn.net/qq_34337272/article/details/79563606" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/79563606</a></p>
<p><img src="https://i.imgur.com/SNXUFvd.png" alt=""></p>
<ol start="2">
<li>pom 文件引入相关依赖</li>
</ol>
<p>需要引入 dubbo 、zookeeper以及接口的相关依赖 jar 包。注意将本项目和 dubbo-interface 项目的 dependency 依赖的 groupId 和 artifactId 改成自己的。dubbo 整合spring boot 的 jar 包在这里找dubbo-spring-boot-starter。zookeeper 的 jar包在 Maven 仓库 搜索 zkclient 即可找到。</p>
<pre><code>&lt;dependency&gt;
      &lt;groupId&gt;top.snailclimb&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo-interface&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!--引入dubbo的依赖--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.0.0&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;!-- 引入zookeeper的依赖 --&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;com.101tec&lt;/groupId&gt;
      &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
      &lt;version&gt;0.10&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre><p>3 在 application.properties 配置文件中配置 dubbo 相关信息</p>
<p>配置很简单，这主要得益于 springboot 整合 dubbo 专属的@EnableDubboConfiguration注解提供的 Dubbo 自动配置。</p>
<pre><code># 配置端口
server.port=8333

spring.dubbo.application.name=dubbo-provider
spring.dubbo.application.registry=zookeeper://ip地址:2181
</code></pre><p>4.实现接口</p>
<p>注意： @Service 注解使用的时 Dubbo 提供的而不是 Spring 提供的。另外，加了Dubbo 提供的 @Service 注解之后还需要加入</p>
<pre><code>package top.snailclimb.service.impl;

import com.alibaba.dubbo.config.annotation.Service;
import org.springframework.stereotype.Component;
import top.snailclimb.service.HelloService;

@Component
@Service
public class HelloServiceImpl implements HelloService {
@Override
public String sayHello(String name) {
    return &quot;Hello &quot; + name;
    }
}
</code></pre><p>5 服务提供者启动类编写</p>
<p>注意：不要忘记加上 @EnableDubboConfiguration 注解开启Dubbo 的自动配置。</p>
<pre><code>package top.snailclimb;

import com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
// 开启dubbo的自动配置
@EnableDubboConfiguration
public class DubboProviderApplication {
public static void main(String[] args) {
    SpringApplication.run(DubboProviderApplication.class, args);
    }
}
</code></pre><p>开始实战 4 ：实现服务消费者 dubbo-consumer</p>
<p>主要分为下面几步：</p>
<pre><code>1 创建 springboot 项目;

2 加入 dubbo 、zookeeper以及接口的相关依赖 jar 包；

3 在 application.properties 配置文件中配置 dubbo 相关信息；

4 编写测试类;

5 服务消费者启动类编写

6 测试效果
</code></pre><p>项目结构：<br><img src="https://i.imgur.com/Znze4m3.png" alt="">        </p>
<p>第1，2，3 步和服务提供者的一样，这里直接从第 4 步开始。</p>
<p>4 编写一个简单 Controller 调用远程服务</p>
<pre><code>package top.snailclimb.dubboconsumer;

import com.alibaba.dubbo.config.annotation.Reference;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import top.snailclimb.service.HelloService;

@RestController
public class HelloController {
@Reference
private HelloService helloService;

@RequestMapping(&quot;/hello&quot;)
public String hello() {
    String hello = helloService.sayHello(&quot;world&quot;);
    System.out.println(helloService.sayHello(&quot;SnailClimb&quot;));
    return hello;
    }
}
</code></pre><p>5 服务消费者启动类编写</p>
<pre><code>package top.snailclimb.dubboconsumer;

import com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@EnableDubboConfiguration
public class DubboConsumerApplication {

public static void main(String[] args) {

    SpringApplication.run(DubboConsumerApplication.class, args);
    }
}
</code></pre><ol start="6">
<li>测试效果</li>
</ol>
<p>浏览器访问 <a href="http://localhost:8330/hello" target="_blank" rel="noopener">http://localhost:8330/hello</a> 页面返回 Hello world，控制台输出 Hello SnailClimb，和预期一直，使用SpringBoot+Dubbo 搭建第一个简单的分布式服务实验成功！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/09/使用SpringBoot-Dubbo搭建一个简单的分布式服务/" data-id="cjr6j5lyg0003ikotlwe5i8kc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sql表连接的几种方式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/09/sql表连接的几种方式/" class="article-date">
  <time datetime="2018-12-09T12:41:45.000Z" itemprop="datePublished">2018-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/09/sql表连接的几种方式/">sql表连接的几种方式 </a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一.SQL 左外连接，右外连接，全连接，内连接</p>
<p>表结构</p>
<p>a表 id name b表 id job parent_id </p>
<pre><code>1  张三      1 23   1 
2  李四      2 34   2 
3  王武      3 34   4
</code></pre><p>a.id同parent_id 存在关系</p>
<p>内连接</p>
<p>inner join与join的结果是一样的</p>
<p>select a.,b. from a inner join b on a.id=b.parent_id</p>
<p>结果是</p>
<p>1 张3 1 23 1 </p>
<p>2 李四 2 34 2</p>
<p>左连接</p>
<p>select a.,b. from a left join b on a.id=b.parent_id</p>
<p>结果是</p>
<p>1 张3 1 23 1 </p>
<p>2 李四 2 34 2 </p>
<p>3 王武 null</p>
<p>右连接</p>
<p>select a.,b. from a right join b on a.id=b.parent_id</p>
<p>结果是</p>
<p>1 张3 1 23 1</p>
<p>2 李四 2 34 2</p>
<p>null 3 34 4</p>
<p>完全连接</p>
<p>select a.,b. from a full join b on a.id=b.parent_id</p>
<p>结果是</p>
<p>1 张3 1 23 1</p>
<p>2 李四 2 34 2</p>
<p>null 3 34 4</p>
<p>3 王武 null</p>
<p>注意：join 默认结果等于inner join</p>
<p>二、自然连接</p>
<p>natural join：自然连接（不允许带on/using）</p>
<p>natrual join：全自然连接，对左右2个表相同名字的列进行等值匹配，不可用on，using操作指定，自动删除多余重名列,自动合并不同的列</p>
<p>natrual left join：左自然连接，保留2个表的列（删除多余重名列），以左表为准，不存在匹配的右表列，值置为NULL</p>
<p>natrual right join：和左自然连接相反</p>
<pre><code>select * from tb_test1 natural join tb_student; 
+—-+——–+——–+——-+————+ 
| id | name | gender | score | birthday | 
+—-+——–+——–+——-+————+ 
| 1 | 李毅 | 男 | 95.30 | 1988-03-20 | 
+—-+——–+——–+——-+————+

select * from tb_test1 natural left join tb_student; 
+—-+———–+——–+——-+————+ 
| id | name | gender | score | birthday | 
+—-+———–+——–+——-+————+ 
| 1 | 李毅 | 男 | 95.30 | 1988-03-20 | 
| 2 | 二丫 | 女 | 95.30 | NULL | 
| 3 | 张三 | 女 | 95.30 | NULL | 
| 4 | 李四 | 女 | 95.30 | NULL | 
| 7 | 胡鲁瓦 | 男 | 95.30 | NULL | 
| 9 | 后羿 | 男 | 95.30 | NULL | 
+—-+———–+——–+——-+————+

select * from tb_test1 natural right join tb_student; 
+—-+——–+——–+————+——-+ 
| id | name | gender | birthday | score | 
+—-+——–+——–+————+——-+ 
| 1 | 李毅 | 男 | 1988-03-20 | 95.30 | 
| 2 | kevin | 男 | 1987-08-23 | NULL | 
| 3 | marry | 女 | 1989-11-25 | NULL | 
| 4 | lucy | 女 | 1989-11-25 | NULL | 
| 5 | lily | 女 | 1992-01-25 | NULL | 
+—-+——–+——–+————+——-+
</code></pre><p>笛卡尔乘积<br>已上连接都是基于cross join(笛卡尔乘积)，即两表行数的乘积</p>
<p>概念:没有where条件的交叉连接将产生连接表所涉及的笛卡尔积。即TableA的行数TableB的行数的结果集。（TableA 3行TableB 3行=9行）</p>
<p>sql语句:</p>
<p>select * from TableA cross join TableB</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/09/sql表连接的几种方式/" data-id="cjr6j5lya0002ikotuvpddh3l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-最全面的SpringBoot配置文件详解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/08/最全面的SpringBoot配置文件详解/" class="article-date">
  <time datetime="2018-12-08T13:55:24.000Z" itemprop="datePublished">2018-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/08/最全面的SpringBoot配置文件详解/">最全面的SpringBoot配置文件详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Spring Boot在工作中是用到的越来越广泛了，简单方便，有了它，效率提高不知道多少倍。Spring Boot配置文件对Spring Boot来说就是入门和基础，经常会用到，所以写下做个总结以便日后查看。</p>
<p>1、配置文件</p>
<p>当我们构建完Spring Boot项目后，会在resources目录下给我们一个默认的全局配置文件 application.properties，这是一个空文件，因为Spring Boot在底层已经把配置都给我们自动配置好了，当在配置文件进行配置时，会修改SpringBoot自动配置的默认值。</p>
<p>配置文件名是固定的</p>
<pre><code>application.properties
</code></pre><p>但我们可以修改为</p>
<pre><code>application.yml
</code></pre><p>这两个文件本质是一样的，区别只是其中的语法略微不同。</p>
<p>2、值的写法</p>
<p>application.properties 配置文件比较简单，形式如下</p>
<pre><code>key = value
</code></pre><p>application.yml 配置文件使用YMAL语言，YMAL不是如XML般的标记语言，更适合作为配置文件。</p>
<p>下面说下对于不同类型（字符串、数组）如何去规范书写。<br>2.1 数字，字符串，布尔</p>
<p>1、直接写</p>
<p>name=zhangsan</p>
<p>2、双引号</p>
<p>不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思</p>
<p>name: “zhangsan \n lisi”</p>
<p>输出：<br>zhangsan<br>lisi</p>
<p>3、单引号</p>
<p>会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
<p>name: ‘zhangsan \n lisi’</p>
<p>输出：</p>
<p>zhangsan \n lisi<br>2.2 对象、Map（属性和值）（键值对）</p>
<p>例如配置类中的字段为</p>
<p>Map&lt;String,String&gt; maps;</p>
<p>在yml配置文件中，行内写法</p>
<p>person.maps: {key1: value1,key2: value2}</p>
<p>需要注意:号后的空格，或者</p>
<p>person:<br>  maps:<br>   key: value</p>
<p>在properties配置文件中</p>
<p>person.maps.key=value</p>
<p>2.3 数组（List、Set）</p>
<p>在yml配置文件中</p>
<p>person:<br>  list:</p>
<ul>
<li>1</li>
<li>2</li>
<li>3</li>
</ul>
<p>行内写法</p>
<p>person:<br>  list: [1,2,3]</p>
<p>在properties配置文件中</p>
<p>person.list[0]=1<br>person.list[1]=2<br>person.list[2]=3</p>
<p>3、自定义配置属性</p>
<p>Spring Boot提供自定义配置组件，拿前面举例的属性来写一个规范的配置文件</p>
<p>@Component // 或者@Configuration</p>
<p>@ConfigurationProperties(prefix = “person”)</p>
<p>public class Person {</p>
<pre><code>private Map&lt;String,String&gt; maps;
private List&lt;String&gt; list;
private String name;

public Map&lt;String, String&gt; getMaps() {
    return maps;
}

public void setMaps(Map&lt;String, String&gt; maps) {
    this.maps = maps;
}

public List&lt;String&gt; getList() {
    return list;
}

public void setList(List&lt;String&gt; list) {
    this.list = list;
}
public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}
</code></pre><p>}</p>
<p>@ConfigurationProperties 注解向Spring Boot声明该类中的所有属性和配置文件中相关的配置进行绑定。</p>
<pre><code>prefix = &quot;person&quot;：声明配置前戳，将该前戳下的所有属性进行映射。
</code></pre><p>@Component 或者@Configuration：将该组件加入Spring Boot容器，只有这个组件是容器中的组件，配置才生效。<br>4、配置自动提示</p>
<p>在配置自定义属性时，如果想要获得和配置Spring Boot属性自动提示一样的功能，则需要加入下面的依赖：</p>
<!--导入配置文件处理器，配置文件进行绑定就会有提示-->
<dependency><br>   <groupid>org.springframework.boot</groupid><br>   <artifactid>spring-boot-configuration-processor</artifactid><br>   <optional>true</optional><br></dependency>

<p>若是依旧无法自动提示，可以尝试开启IDE的Annonation Processing<br><img src="https://i.imgur.com/wUxSaSX.png" alt=""></p>
<p>5、配置属性校验</p>
<p>自定义配置文件时，可以使用@Validated注解对注入的值进行一些简单的校验，示例代码</p>
<p>@Validated</p>
<p>@Configuration</p>
<p>@ConfigurationProperties(prefix = “person”)</p>
<p>public class Person {</p>
<pre><code>@Email
private String mail;

public String getMail() {
    return mail;
}

public void setMail(String mail) {
    this.mail = mail;
}
</code></pre><p>}</p>
<p>@Email 注解会对mail字段的注入值进行检验，如果注入的不是一个合法的邮件地址则会抛出异常。</p>
<p>其它常见注解：</p>
<pre><code>@AssertFalse  校验false

@AssertTrue  校验true

@DecimalMax(value=,inclusive=)  小于等于value，inclusive=true，是小于等于

@DecimalMin(value=,inclusive=)  与上类似

@Max(value=)  小于等于value

@Min(value=)  大于等于value

@NotNull   检查Null

@Past   检查日期

@Pattern(regex=,flag=)  正则

@Size(min=, max=)  字符串，集合，map限制大小

@Validate   对po实体类进行校验
</code></pre><p>上述的这些注解位于javax.validation.constraints包下，具体用法查看注释即可了解。</p>
<p>6、自定义配置文件</p>
<p>除了在默认的application文件进行属性配置，我们也可以自定义配置文件，例如新建 peoson.properties ，配置内容如下</p>
<p><a href="mailto:person.mail=yster@foxmail.com" target="_blank" rel="noopener">person.mail=yster@foxmail.com</a></p>
<p>然后在配置类中使用@PropertySource注解注入该配置文件</p>
<p>@Configuration</p>
<p>@ConfigurationProperties(prefix = “person”)</p>
<p>@PropertySource(value = “classpath:person.properties”)</p>
<p>public class Person {<br>    private String mail;</p>
<pre><code>public String getMail() {
    return mail;
}

public void setMail(String mail) {
    this.mail = mail;
}
</code></pre><p>}</p>
<p>测试@PropertySource注解不支持注入yml文件。</p>
<pre><code>扩展：@ImportResource：该注解导入Spring的xml配置文件，让配置文件里面的内容生效。

例如：@ImportResource(locations = {&quot;classpath:beans.xml&quot;})
</code></pre><p>7、配置文件占位符</p>
<p>Spring Boot配置文件支持占位符，一些用法如下<br>7.1 随机数</p>
<p>${random.value}</p>
<p>${random.int}</p>
<p>${random.long}</p>
<p>${random.int(10)}</p>
<p>${random.int[1024,65536]}</p>
<p>7.2 默认值</p>
<p>占位符获取之前配置的值，如果没有可以是用:指定默认值</p>
<p>person.last-name=张三${random.uuid}</p>
<p>person.age=${random.int}</p>
<p>person.birth=2017/12/15</p>
<p>person.boss=false</p>
<p>person.maps.k1=v1</p>
<p>person.maps.k2=14</p>
<p>person.lists=a,b,c</p>
<p>person.dog.name=${person.hello:hello}_dog</p>
<p>person.dog.age=15</p>
<p>8、多配置文件<br>8.1 多Profile文件</p>
<p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml</p>
<p>默认使用application.properties的配置</p>
<p>8.2 yml支持多文档块方式</p>
<p>通过—可以把一个yml文档分割为多个，并可以通过 spring.profiles.active 属性指定使用哪个配置文件</p>
<pre><code>server:
  port: 8081
spring:
      profiles:
        active: prod #指定使用哪个环境

---
server:
      port: 8083
spring:
      profiles: dev  #指定属于哪个环境


---

server:
      port: 8084
spring:
      profiles: prod  #指定属于哪个环境
</code></pre><p>8.3 激活指定profile</p>
<p>无论是使用上述多文档块的方式，还是新建application-dev.yml文件，都可以在配置文件中指定  spring.profiles.active=dev 激活指定的profile，或者</p>
<p>1、使用命令行：</p>
<p>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev</p>
<p>可以直接在测试的时候，配置传入命令行参数</p>
<p>2、虚拟机参数：</p>
<p>-Dspring.profiles.active=dev</p>
<p>9、配置文件加载位置</p>
<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>
<pre><code>–file:./config/

–file:./

–classpath:/config/

–classpath:/
</code></pre><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；SpringBoot会从这四个位置全部加载主配置文件。</p>
<p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</p>
<p>我们还可以通过spring.config.location来改变默认的配置文件位置，示例：</p>
<p>java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties</p>
<p>10、外部配置加载顺序</p>
<p>SpringBoot也可以从以下位置加载配置，优先级从高到低，高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置。</p>
<p>1、命令行参数</p>
<p>所有的配置都可以在命令行上进行指定</p>
<p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p>
<p>多个配置用空格分开，形如 –配置项=值</p>
<p>2、来自java:comp/env的JNDI属性</p>
<p>3、Java系统属性（System.getProperties()）</p>
<p>4、操作系统环境变量</p>
<p>5、RandomValuePropertySource配置的random.*属性值</p>
<p>由jar包外向jar包内进行寻找</p>
<p>优先加载带{profile}</p>
<p>6、jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p>
<p>7、jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p>
<p>再来加载不带profile</p>
<p>8、jar包外部的application.properties或application.yml(不带spring.profile)配置文件</p>
<p>9、jar包内部的application.properties或application.yml(不带spring.profile)配置文件</p>
<p>10、@Configuration注解类上的@PropertySource</p>
<p>11、通过SpringApplication.setDefaultProperties指定的默认属性</p>
<p>11、自动配置原理</p>
<p>11.1 自动配置原理</p>
<p>1、SpringBoot启动的时候加载主配置类，@EnableAutoConfiguration注解开启了自动配置功能。</p>
<p>2、@EnableAutoConfiguration 作用：</p>
<pre><code>利用EnableAutoConfigurationImportSelector给容器中导入一些组件

可以查看selectImports()方法的内容；

List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,  attributes);获取候选的配置

SpringFactoriesLoader.loadFactoryNames()
扫描所有jar包类路径下  META-INF/spring.factories
把扫描到的这些文件的内容包装成properties对象
从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中
</code></pre><p>将类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中</p>
<p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中,用他们来做自动配置。</p>
<h1 id="Auto-Configure"><a href="#Auto-Configure" class="headerlink" title="Auto Configure"></a>Auto Configure</h1><p>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\<br>……</p>
<p>3、对每一个自动配置类进行自动配置功能。</p>
<p>4、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理；</p>
<p>@Configuration   //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件<br>@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</p>
<p>@ConditionalOnWebApplication<br>//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；判断当前应用是否是web应用，如果是，当前配置类生效</p>
<p>@ConditionalOnClass(CharacterEncodingFilter.class)<br>//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</p>
<p>@ConditionalOnProperty(prefix = “spring.http.encoding”, value = “enabled”, matchIfMissing = true)<br>//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的<br>//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</p>
<p>public class HttpEncodingAutoConfiguration {</p>
<pre><code>//他已经和SpringBoot的配置文件映射了
private final HttpEncodingProperties properties;
</code></pre><p>   //只有一个有参构造器的情况下，参数的值就会从容器中拿<br>      public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {<br>        this.properties = properties;<br>    }</p>
<pre><code>@Bean   //给容器中添加一个组件，这个组件的某些值需要从properties中获取
@ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件
public CharacterEncodingFilter characterEncodingFilter() {
    CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
    filter.setEncoding(this.properties.getCharset().name());
    filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
    filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
    return filter;
}
</code></pre><p>根据当前不同的条件判断，决定这个配置类是否生效。</p>
<p>一但这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的。</p>
<p>5、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者，配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<p>@ConfigurationProperties(prefix = “spring.http.encoding”)  //从配置文件中获取指定的值和bean的属性进行绑定</p>
<p>public class HttpEncodingProperties {</p>
<p>   public static final Charset DEFAULT_CHARSET = Charset.forName(“UTF-8”);</p>
<p>精髓：</p>
<p>1） SpringBoot启动会加载大量的自动配置类</p>
<p>2） 先看我们需要的功能有没有SpringBoot默认写好的自动配置类</p>
<p>3） 再来看这个自动配置类中到底配置了哪些组件（只要我们要用的组件有，我们就不需要再来配置了）</p>
<p>4） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值</p>
<p>xxxxAutoConfigurartion：自动配置类；给容器中添加组件；</p>
<p>xxxxProperties:封装配置文件中相关属性；</p>
<p>11.2 @Conditional注解</p>
<p>@Conditional派生注解（Spring注解版原生的@Conditional作用）</p>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效。</p>
<p>@Conditional扩展注解    作用（判断是否满足当前指定条件）<br>@ConditionalOnJava    系统的java版本是否符合要求<br>@ConditionalOnBean    容器中存在指定Bean；<br>@ConditionalOnMissingBean    容器中不存在指定Bean；<br>@ConditionalOnExpression    满足SpEL表达式指定<br>@ConditionalOnClass    系统中有指定的类<br>@ConditionalOnMissingClass    系统中没有指定的类<br>@ConditionalOnSingleCandidate    容器中只有一个指定的Bean，或者这个Bean是首选Bean<br>@ConditionalOnProperty    系统中指定的属性是否有指定的值<br>@ConditionalOnResource    类路径下是否存在指定资源文件<br>@ConditionalOnWebApplication    当前是web环境<br>@ConditionalOnNotWebApplication    当前不是web环境<br>@ConditionalOnJndi    JNDI存在指定项</p>
<p>自动配置类必须在一定的条件下才能生效。</p>
<p>我们怎么知道哪些自动配置类生效？</p>
<p>我们可以通过在properties（yml）启用  debug=true 属性来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效。</p>
<pre><code>`============================
</code></pre><h1 id="CONDITIONS-EVALUATION-REPORT"><a href="#CONDITIONS-EVALUATION-REPORT" class="headerlink" title="CONDITIONS EVALUATION REPORT"></a>CONDITIONS EVALUATION REPORT</h1><h2 id="Positive-matches-（自动配置类启用的）"><a href="#Positive-matches-（自动配置类启用的）" class="headerlink" title="Positive matches:（自动配置类启用的）"></a>Positive matches:（自动配置类启用的）</h2><p>   CodecsAutoConfiguration matched:</p>
<pre><code>- @ConditionalOnClass found required class &apos;org.springframework.http.codec.CodecConfigurer&apos;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)
</code></pre><p>   CodecsAutoConfiguration.JacksonCodecConfiguration matched:</p>
<pre><code>- @ConditionalOnClass found required class &apos;com.fasterxml.jackson.databind.ObjectMapper&apos;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)
</code></pre><p>…….</p>
<h2 id="Negative-matches-（没有启动，没有匹配成功的自动配置类）"><a href="#Negative-matches-（没有启动，没有匹配成功的自动配置类）" class="headerlink" title="Negative matches:（没有启动，没有匹配成功的自动配置类）"></a>Negative matches:（没有启动，没有匹配成功的自动配置类）</h2><p>   ActiveMQAutoConfiguration:</p>
<pre><code>Did not match:

   - @ConditionalOnClass did not find required classes &apos;javax.jms.ConnectionFactory&apos;, &apos;org.apache.activemq.ActiveMQConnectionFactory&apos; (OnClassCondition)
</code></pre><p>   AopAutoConfiguration:</p>
<pre><code>Did not match:

   - @ConditionalOnClass did not find required classes &apos;org.aspectj.lang.annotation.Aspect&apos;, &apos;org.aspectj.lang.reflect.Advice&apos;, &apos;org.aspectj.weaver.AnnotatedElement&apos; (OnClassCondition)`
</code></pre><p>参考</p>
<p>docs.spring.io官方文档：</p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/08/最全面的SpringBoot配置文件详解/" data-id="cjr6j5lzh0007ikotra6edskk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java基础" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/java基础/" class="article-date">
  <time datetime="2018-11-15T15:34:36.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/java基础/">java基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一.java中的数据类型</p>
<p> 1.基本数据类型:四类 八种</p>
<pre><code>byte(1) boolean(1) short(2) char(2) int(4) float(4) long(8) double(8)
</code></pre><p> 2.引用数据类型</p>
<pre><code>String , 数组,集合ArrayList,Scanner,Random,自定义类型
</code></pre><p> 二.引用数据类型String中的方法(4532)</p>
<p> 第一组:判断方法</p>
<pre><code>boolean equals(String str);//比较两个字符串的内容是否相等
boolean equalsIgnoreCase(String str);//比较两个字符串的内容是相等(忽略大小写)
boolean startsWith(String subStr);//判断某个字符串是否以指定的子串开头
boolean endsWith(String subStr);//判断某个字符串是否以指定的子串结尾
</code></pre><p> 第二组:获取方法</p>
<pre><code>int length();//获取字符串中字符个数
char charAt(int index);//获取字符串中某一个字符
String substring(int startIndex);//从指定下标开始截取字符串,直到字符串的末尾
String substring(int startIndex,int endIndex);//从指定下标开始截取字符串,到指定下标结束(包括开头不包括结尾)
---可忽略  int indexof(String subStr);//获取子串第一次出现的下标
</code></pre><p> 第三组:转换方法</p>
<pre><code>String toLowerCase();//转成小写串
String toUpperCase();//转成大写串
Char[] toCharArray();//变成字符数组
</code></pre><p> 第四组:其他方法</p>
<pre><code>String trim();//去掉字符串两端的空格
String[] split(String str);//切割字符串
</code></pre><p> 三:流_读写文件</p>
<pre><code>    输出流:数据从java程序 到  文件中
    FileWriter:文件的字符输出流,写数据(一个字符,一个字符串,一个字符数组)
        write(int ch);//写一个字符(可以写字符的ASCII码值)
        write(char[] chs);//写一个字符数组
        write(String s);//写一个字符串
        write(char[] chs,int startIndex,int len);//写一个字符数组的一部分
        write(String s,int startInex,int len);//写一个字符串的一部分

    输入流:数据从 文件 到java程序
    FileReader:文件的字符输入流,读数据(一个字符,一个字符数组)
        int read();//读取一个字符
        int read(char[] chs);//一个读取一个字符数组,返回值表示实际读取到的字符的个数

    文件的路径分为两种:
    1.相对路径:
        相对于当前项目而言的

    2.绝对路径:
        以盘符开头  C: D:
四:对象的内存图:
    Dog d = new Dog();
    d是引用数据类型,保存到栈(stack)中
    new Dog();创建对象,保存到堆(heap)中
</code></pre><p>  五:this的作用以及本质</p>
<pre><code>作用:区分局部变量和成员变量的同名的情况
本质:this代表一个对象,具体是哪一个对象,那么由方法的调用者决定
</code></pre><p>  六:匿名对象:</p>
<pre><code>语法: 只创建对象,而不是变量来接收
    比如: new Dog(); new Student()
特点:一个匿名对象 只能使用一次,第二次使用就是一个新的匿名对象
</code></pre><p>  ***继承</p>
<pre><code>1.概念:
    描述两个类之间的关系(子类和父类之间的关系)
    一个类(子类) 在另外一个类(父类)的基础上创建,那么这个过程就叫做继承
2.语法:
    public class 父类{}
    public class 子类 extends 父类{}
3.继承的作用:
    子类自动拥有父类的可继承(非private修饰的)的成员变量和成员方法
    提高了代码的服用性
4.继承中子父类的成员变量和成员方法的特点:
    如果子父类中出现了同名的成员变量或者成员方法
        通过子类对象调用成员变量或者成员方法时,优先调用子类自己的,如果子类没有,再去访问父类的
5.java中继承的特点:
    1.java只支持单继承: 一个子类 只能有一个直接父类
    2.java中支持多层继承
    3.子类自动拥有父类的可继承(非private修饰的)的成员变量和成员方法
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/15/java基础/" data-id="cjr6j5lx40001ikotmi0mlnxs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/hello-world/" class="article-date">
  <time datetime="2018-11-15T14:41:59.501Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/15/hello-world/" data-id="cjr6j5lwn0000ikot59jo2d7x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/22/多表查询/">多表查询</a>
          </li>
        
          <li>
            <a href="/2019/01/21/SQL语句查询/"> SQL语句查询</a>
          </li>
        
          <li>
            <a href="/2019/01/20/数据库篇多表操作/">数据库篇多表操作</a>
          </li>
        
          <li>
            <a href="/2019/01/19/数据库篇一/">数据库篇一</a>
          </li>
        
          <li>
            <a href="/2019/01/17/XML/">XML</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Zhang Bin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>