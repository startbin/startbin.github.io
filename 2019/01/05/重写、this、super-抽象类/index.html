<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>重写、this、super,抽象类 | Quantity Accumulation and Quality Leap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="继承1.1    继承中子类中出现与父类重名的成员变量 当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。 在子类中，访问父类中的成员变量格式：  super.父类中的成员变量 看如下代码：    class Fu    {    //Fu中的成员变量。    int num = 5;    }    class Zi extends Fu    {">
<meta property="og:type" content="article">
<meta property="og:title" content="重写、this、super,抽象类">
<meta property="og:url" content="http://yoursite.com/2019/01/05/重写、this、super-抽象类/index.html">
<meta property="og:site_name" content="Quantity Accumulation and Quality Leap">
<meta property="og:description" content="继承1.1    继承中子类中出现与父类重名的成员变量 当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。 在子类中，访问父类中的成员变量格式：  super.父类中的成员变量 看如下代码：    class Fu    {    //Fu中的成员变量。    int num = 5;    }    class Zi extends Fu    {">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://i.imgur.com/qZ5yxjO.png">
<meta property="og:image" content="https://i.imgur.com/0Omzpgw.png">
<meta property="og:image" content="https://i.imgur.com/KiIbOwp.png">
<meta property="og:updated_time" content="2019-01-05T13:00:17.321Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="重写、this、super,抽象类">
<meta name="twitter:description" content="继承1.1    继承中子类中出现与父类重名的成员变量 当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。 在子类中，访问父类中的成员变量格式：  super.父类中的成员变量 看如下代码：    class Fu    {    //Fu中的成员变量。    int num = 5;    }    class Zi extends Fu    {">
<meta name="twitter:image" content="https://i.imgur.com/qZ5yxjO.png">
  
    <link rel="alternate" href="/atom.xml" title="Quantity Accumulation and Quality Leap" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Quantity Accumulation and Quality Leap</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-重写、this、super-抽象类" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/05/重写、this、super-抽象类/" class="article-date">
  <time datetime="2019-01-05T12:54:21.000Z" itemprop="datePublished">2019-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      重写、this、super,抽象类
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>继承<br>1.1    继承中子类中出现与父类重名的成员变量</p>
<p>当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。</p>
<pre><code>在子类中，访问父类中的成员变量格式：

super.父类中的成员变量
</code></pre><p>看如下代码：<br>    class Fu<br>    {<br>    //Fu中的成员变量。<br>    int num = 5;<br>    }<br>    class Zi extends Fu<br>    {<br>    //Zi中的成员变量<br>    int num = 6;<br>    void show()<br>    {<br>        //子父类中出现了同名的成员变量时<br>        //在子类中需要访问父类中非私有成员变量时，需要使用super关键字<br>        //访问父类中的num<br>        System.out.println(“Fu num=”+super.num);<br>        //访问子类中的num2<br>        System.out.println(“Zi num2=”+this.num);<br>    }<br>    }<br>    class Demo5<br>    {<br>    public static void main(String[] args)<br>    {<br>        Zi z = new Zi(); //创建子类对象<br>        z.show(); //调用子类中的show方法<br>    }<br>    }</p>
<p>1.2    继承后子类对象的内存图</p>
<p>当子类创建对象后，该子类对象本身可以使用this来指代，而该对象当中的父类空间可以使用super来指代。</p>
<p>如下为加入了子父类关系后的对象内存图。</p>
<p>继承后对象内存图</p>
<p><img src="https://i.imgur.com/qZ5yxjO.png" alt=""></p>
<p>1.3    继承中方法重写&amp;应用</p>
<p>    子父类成员方法特殊情况——覆盖</p>
<p>子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖。</p>
<pre><code>class Fu
{
public void show()
{
    System.out.println(&quot;Fu show&quot;);
}
}
class Zi extends Fu
{
//子类复写了父类的show方法
public void show()
{
    System.out.println(&quot;Zi show&quot;);
}
}
</code></pre><p>   方法重写（覆盖）的应用：<br>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。</p>
<p>举例：比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能，后期由于手机需要在来电显示功能中增加显示姓名和头像，这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能。</p>
<p>在子类中，访问父类中的成员方法格式：<br>super.父类中的成员方法();</p>
<p>看如下代码：</p>
<pre><code>public class Test {
public static void main(String[] args) {
    new NewPhone().showNum();
}
}

//手机类
class Phone{
public void sendMessage(){
    System.out.println(&quot;发短信&quot;);
}
public void call(){
    System.out.println(&quot;打电话&quot;);
}
public void showNum(){
    System.out.println(&quot;来电显示号码&quot;);
}
}

//智能手机类
class NewPhone extends Phone{

//覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能
public void showNum(){
    //调用父类已经存在的功能使用super
    super.showNum();
    //增加自己特有显示姓名和图片功能
    System.out.println(&quot;显示来电姓名&quot;);
    System.out.println(&quot;显示头像&quot;);
}
}
</code></pre><p>1.4    方法重写的注意事项</p>
<p>重写需要注意的细节问题：</p>
<p>    子类方法覆盖/重写/覆写(override)父类方法，必须要保证权限大于等于父类权限。</p>
<pre><code>class Fu(){    
void show(){}
    public void method(){}
}
class Zi() extends Fu{
public void show(){}  //编译运行没问题
    void method(){}      //编译错误
}
</code></pre><p>    如果父类的方法是private的修饰的,那么在子类中没法重写(其他修饰符都可以重写)</p>
<p>    写法上稍微注意:必须一模一样:方法的返回值类型 方法名 参数列表都要一样。</p>
<p>总结：当一个类是另一个类中的一种时，可以通过继承，来继承属性与功能。如果父类具备的功能内容需要子类特殊定义时，进行方法重写。</p>
<p>1.5    this与super调用普通成员与构造方法</p>
<pre><code>调用普通成员：
this.成员变量       可以访问本类对象的成员变量
super.成员变量     可以访问父类对象的成员变量

this.成员方法()     可以访问本类对象的成员方法
super.成员方法()    可以访问父类对象的成员方法

使用this找本类,如果子类没有找父类
使用super找父类,如果父类没有不会去找子类

调用构造方法：
this(其他参数)      可以访问本类其他的构造方法
super(其他参数)    可以访问父类其他的构造方法

   默认子类调用父类构造方法
子类的每个构造方法中均有默认的super(),调用父类的空参构造。手动调用父类构造会覆盖默认的super();
</code></pre><p>1.6    [扩展1]使用this调用其他构造方法</p>
<pre><code>public class Person {
private int age;
public Person(){
    this(15);//这句话调用 下面带int参数构造
}
public Person(int age){
    this.age = age;
}
public int getAge() {
    return age;
}
public void setAge(int age) {
    this.age = age;
}
}
/*
 *  以前this.这种形式;
 *  现在:this() 语句形式
 *  调用本类中的其他构造方法
 *  注意:this()语句形式必须写在构造方法的第一行
 */
public class Test {
public static void main(String[] args) {
    Person p = new Person();
    int a = p.getAge();
    System.out.println(a);

/*    Person p1 = new Person(15);
    a = p1.getAge();
    System.out.println(a);*/
}
}
</code></pre><p>需求1,创建一个人的对象,要求:无论通过何种构造方法创建,人对象的年龄就是10岁.</p>
<p>1.7    [扩展2]使用super调用父类的构造方法</p>
<p>一.子类的每个每个每个构造方法中均有默认的super(),调用父类的空参构造</p>
<pre><code>public class Fu {

    public Fu(){
        System.out.println(&quot;父类的构造方法&quot;);
    }
}

public class Zi extends Fu{
int a;
    public Zi(){
        //super();
        System.out.println(&quot;子类的构造方法&quot;);
    }
public Zi(int a){
        this.a = a;
        System.out.println(&quot;子类的构造方法&quot;);
    }


}
public class Test {
    public static void main(String[] args) {
        new Zi();//匿名对象
}
}
</code></pre><p>二.  super()调用的是父类无参的构造方法  但是能不能调用父类其他有参构造呢?</p>
<pre><code>public class Fu {
int a;
    public Fu(){
        System.out.println(&quot;父类的构造方法&quot;);
    }
public Fu(int a){
        this.a = a;
    }

}

public class Zi extends Fu{
    public Zi(){
           System.out.println(&quot;子类的构造方法&quot;);
    }
}
public class Test {
    public static void main(String[] args) {
        new Zi();//匿名对象
}
}
</code></pre><p>思考:<br>Java设计的时候为什么这么干????<br>原因[了解]:<br>      Java设计的时候坚持了一个原则,谁污染谁治理,谁的孩子谁负责<br>                                    谁的成员变量 谁初始化(类不能太累,单一职责原则)</p>
<p>18.this与super</p>
<p>18.1父类对象空间优于子类对象产生</p>
<p>在每次创建子类对象时，我们均会先创建父类对象，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类对象空间，便可以包含其父类对象的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。</p>
<p>代码体现在子类的构造方法调用时，一定先调用父类的构造方法。</p>
<p>18.2继承关系图(this与super)</p>
<p>当子类创建对象后，该子类对象本身可以使用this来指代，而该对象当中的父类对象空间可以使用super来指代。</p>
<p>如下为加入了子父类关系后的对象内存图。</p>
<pre><code>以Person类为例：

//定义父类
public class Person {
    private String name;
    private int age;

    public Person(){}
    public Person(String name,int age) {
        this.name = name;
        this.age = age;
     }
    //get/set方法
 }

//定义子类
public class Chinese extends Person{
private String address;
public Chinese(){}
public Chinese(String name,int age,String address) {
    super(name,age);
    this.address = address;
}
//对address的get/set
}


//定义测试类,使用子类创建对象
public class Test{
Chinese c = new Chinese(“AngelaBaby”,18,”北京海淀区上地软件园”);
}

继承后对象内存图
</code></pre><p><img src="https://i.imgur.com/0Omzpgw.png" alt=""></p>
<p>第2章    抽象类</p>
<p>2.1    抽象类-产生</p>
<p>当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的功能具体实现方式，那么这些方法都有具体的方法体。</p>
<p>但是有的时候，某个父类只是知道子类应该包含怎么样的方法，但是无法准确知道子类如何实现这些方法。</p>
<p>比如一个图形类应该有一个求周长的方法，但是不同的图形求周长的算法不一样。那该怎么办呢？</p>
<p>再比如:动物应该有吃饭的方法,猫,狗,猪…. 那么在他们的父类中 这个吃方法应该怎么定义?</p>
<p>分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。</p>
<pre><code>如：
描述讲师的行为：工作。
描述助教的行为：工作。
描述班主任的行为：工作。
讲师、助教、班主任之间有共性，可以进行向上抽取。抽取它们的所属共性类型：员工。由于讲师、助教、班主任都具有工作功能，但是他们具体工作内容却不一样。这时在描述员工时，发现了有些功能不能够具体描述，那么，这些不具体的功能，需要在类中标识出来，通过java中的关键字abstract(抽象)修饰。
</code></pre><p>当定义了抽象函数的类也必须被abstract关键字修饰，被abstract关键字修饰的类是抽象类。</p>
<p>2.2    抽象类&amp;抽象方法的定义</p>
<p>抽象方法定义的格式：</p>
<p>public abstract 返回值类型 方法名(参数);</p>
<p>抽象类定义的格式：</p>
<pre><code>abstract class 类名 {
}
</code></pre><p>看如下代码：</p>
<pre><code>//员工
abstractclass Employee{
    public abstract void work();//抽象函数。需要abstract修饰，并分号;结束
}

//讲师
class Teacher extends Employee {
    publicvoid work() {
        System.out.println(&quot;正在讲解Java&quot;);
    }
}

//助教
class Assistant extends Employee {
    publicvoid work() {
        System.out.println(&quot;正在辅导学生&quot;);
    }
}

//班主任
class Manager extends Employee {
    publicvoid work() {
        System.out.println(&quot;正在管理班级&quot;);
    }
}
</code></pre><p>2.3    抽象类&amp;抽象方法的使用</p>
<p>抽象类无法直接创建对象，只能被子类继承后，创建子类对象。</p>
<p>子类需要继承抽象父类并完成最终的方法实现细节(即重写方法，完成方法体)。而此时，方法重写不再是加强父类方法功能，而是父类没有具体实现，子类完成了具体实现，我们将这种方法重写也叫做实现方法。</p>
<p>抽象类是拥有构造方法的，其存在的意义在于对自身进行初始化，供其子类使用。</p>
<p>2.4    抽象类常见疑惑</p>
<p>    抽象类一定可以是个父类，因为抽象类时不断抽取共性需求而来的。</p>
<p>    抽象类中是可以不定义抽象方法的，此时仅仅是不让该类创建对象，用于某些特殊的设计需要。</p>
<p>    设计时由具体类抽取出抽象类，而开发阶段应该先定义抽象父类，再根据不同需求由父类定义子类。</p>
<p>第3章    综合案例—员工类系列定义</p>
<p>3.1    案例介绍</p>
<p>某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师.</p>
<p>公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。</p>
<pre><code>    工作内容
    JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站
    Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件
    网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通
    硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机
</code></pre><p>请根据描述，完成员工体系中所有类的定义，并指定类之间的继承关系。进行XX工程师类的对象创建，完成工作方法的调用。</p>
<p>3.2    案例分析</p>
<p>    根据上述部门的描述，得出如下的员工体系图</p>
<p><img src="https://i.imgur.com/KiIbOwp.png" alt=""></p>
<p>    根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。则，把这些共同的属性与功能抽取到父类中（员工类），关于工作的内    容由具体的工程师来进行指定。</p>
<pre><code>    工作内容
    JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站
    Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件
    网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通
    硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机
</code></pre><p>    创建JavaEE工程师对象，完成工作方法的调用</p>
<p>3.3    案例代码实现</p>
<p>    根据员工体系图，完成类的定义</p>
<p>定义员工类(抽象类)</p>
<pre><code>publicabstractclass Employee {
private String id;// 员工编号
private String name; // 员工姓名

public String getId() {
    returnid;
}
publicvoid setId(String id) {
    this.id = id;
}
public String getName() {
    returnname;
}
publicvoid setName(String name) {
    this.name = name;
}

//工作方法（抽象方法）
publicabstractvoid work();
}
</code></pre><p>    定义研发部员工类Developer 继承 员工类Employee</p>
<pre><code>publicabstractclass Developer extends Employee {
}
</code></pre><p>    定义维护部员工类Maintainer 继承 员工类Employee</p>
<pre><code>publicabstractclass Maintainer extends Employee {
}
</code></pre><p>    定义JavaEE工程师 继承 研发部员工类，重写工作方法</p>
<pre><code>publicclass JavaEE extends Developer {
    @Override
    publicvoid work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝网站&quot;);
    }
}
</code></pre><p>    定义Android工程师 继承 研发部员工类，重写工作方法</p>
<pre><code>publicclass Android extends Developer {
    @Override
    publicvoid work() {
        System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝手机客户端软件&quot;);
    }
}
</code></pre><p>    定义Network网络维护工程师 继承 维护部员工类，重写工作方法</p>
<pre><code>publicclass Network extends Maintainer {
@Override
publicvoid work() {
    System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在检查网络是否畅通&quot;);
}
}
</code></pre><p>    定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法</p>
<pre><code>publicclass Hardware extends Maintainer {
@Override
publicvoid work() {
    System.out.println(&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在修复打印机&quot;);
}
}
</code></pre><p>    在测试类中，创建JavaEE工程师对象，完成工作方法的调用</p>
<pre><code>publicclass Test {
publicstaticvoid main(String[] args) {
    //创建JavaEE工程师员工对象
    JavaEE ee = new JavaEE();
    //设置该员工的编号
    ee.setId(&quot;000015&quot;);
    //设置该员工的姓名
    ee.setName(&quot;小明&quot;);
    //调用该员工的工作方法
    ee.work();
}
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/05/重写、this、super-抽象类/" data-id="cjqjh7uwt0003soot1jg0osw4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/01/04/面向对象/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">面向对象</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/05/重写、this、super-抽象类/">重写、this、super,抽象类</a>
          </li>
        
          <li>
            <a href="/2019/01/04/面向对象/">面向对象</a>
          </li>
        
          <li>
            <a href="/2018/12/09/使用SpringBoot-Dubbo搭建一个简单的分布式服务/">使用SpringBoot+Dubbo搭建一个简单的分布式服务</a>
          </li>
        
          <li>
            <a href="/2018/12/09/sql表连接的几种方式/">sql表连接的几种方式 </a>
          </li>
        
          <li>
            <a href="/2018/12/08/最全面的SpringBoot配置文件详解/">最全面的SpringBoot配置文件详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Zhang Bin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>